
build/images/start_dt_2nd.pbl:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <start_dt_2nd>:
 * Mark a imd entry as used so that the linker cannot
 * throw it away.
 */
void imd_used(const void *used)
{
}
       0:	d503201f 	nop
       4:	14000011 	b	48 <start_dt_2nd+0x48>
       8:	00080000 	.word	0x00080000
       c:	00000000 	.word	0x00000000
      10:	0012e5a8 	.word	0x0012e5a8
      14:	00000000 	.word	0x00000000
      18:	0000000a 	.word	0x0000000a
	...
      38:	644d5241 	.word	0x644d5241
      3c:	00000000 	.word	0x00000000
      40:	65726162 	.word	0x65726162
      44:	00786f62 	.word	0x00786f62
      48:	10fffdc1 	adr	x1, 0 <start_dt_2nd>
      4c:	9100003f 	mov	sp, x1
      50:	140006d4 	b	1ba0 <dt_2nd_aarch64>

0000000000000054 <__bare_init_start>:
      54:	00000000 	udf	#0

0000000000000058 <arm_cpu_lowlevel_init>:
      58:	d5384241 	mrs	x1, currentel
      5c:	f100303f 	cmp	x1, #0xc
      60:	540000a0 	b.eq	74 <arm_cpu_lowlevel_init+0x1c>  // b.none
      64:	f100203f 	cmp	x1, #0x8
      68:	540001a0 	b.eq	9c <arm_cpu_lowlevel_init+0x44>  // b.none
      6c:	f100103f 	cmp	x1, #0x4
      70:	540001c0 	b.eq	a8 <arm_cpu_lowlevel_init+0x50>  // b.none
      74:	d53e1100 	mrs	x0, scr_el3
      78:	b2400c00 	orr	x0, x0, #0xf
      7c:	d51e1100 	msr	scr_el3, x0
      80:	d51e115f 	msr	cptr_el3, xzr
      84:	d53e1000 	mrs	x0, sctlr_el3
      88:	58000181 	ldr	x1, b8 <done+0x4>
      8c:	8a210000 	bic	x0, x0, x1
      90:	d51e1000 	msr	sctlr_el3, x0
	uint8_t *bp = (uint8_t *)property;

	bp[0] = value >> 24;
	bp[1] = (value >> 16) & 0xff;
	bp[2] = (value >> 8) & 0xff;
	bp[3] = value & 0xff;
      94:	d5033fdf 	isb
	bp[0] = value >> 24;
      98:	14000007 	b	b4 <done>
	} else {
		return -FDT_ERR_BADNCELLS;
	}

	/* check validity of size */
	prop += addr_cells * sizeof(fdt32_t);
      9c:	d2867fe0 	mov	x0, #0x33ff                	// #13311
      a0:	d51c1140 	msr	cptr_el2, x0
      a4:	14000004 	b	b4 <done>
	if (size_cells == 1) {
      a8:	d2a00600 	mov	x0, #0x300000              	// #3145728
      ac:	d5181040 	msr	cpacr_el1, x0
		if (size > UINT32_MAX)
      b0:	14000001 	b	b4 <done>

00000000000000b4 <done>:
      b4:	d65f03c0 	ret
      b8:	0020100f 	.word	0x0020100f
	bp[3] = value & 0xff;
      bc:	00000000 	.word	0x00000000

00000000000000c0 <get_runtime_offset>:
	bp[0] = value >> 24;
      c0:	10fffa00 	adr	x0, 0 <start_dt_2nd>
	} else {
		return -FDT_ERR_BADNCELLS;
	}

	return fdt_appendprop(fdt, nodeoffset, name, data,
			      (addr_cells + size_cells) * sizeof(fdt32_t));
      c4:	f0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
	return fdt_appendprop(fdt, nodeoffset, name, data,
      c8:	f946a021 	ldr	x1, [x1, #3392]
      cc:	eb010000 	subs	x0, x0, x1
      d0:	d65f03c0 	ret

00000000000000d4 <__bare_init_end>:
	...

00000000000000e0 <fdt_ro_probe_>:
      e0:	39401002 	ldrb	w2, [x0, #4]
      e4:	39401401 	ldrb	w1, [x0, #5]
      e8:	aa012041 	orr	x1, x2, x1, lsl #8
      ec:	39401802 	ldrb	w2, [x0, #6]
      f0:	aa024022 	orr	x2, x1, x2, lsl #16
      f4:	39401c01 	ldrb	w1, [x0, #7]
      f8:	aa016041 	orr	x1, x2, x1, lsl #24
      fc:	5ac00821 	rev	w1, w1
     100:	f240081f 	tst	x0, #0x7
     104:	54000661 	b.ne	1d0 <fdt_ro_probe_+0xf0>  // b.any
     108:	39400003 	ldrb	w3, [x0]
     10c:	39400402 	ldrb	w2, [x0, #1]
     110:	aa022062 	orr	x2, x3, x2, lsl #8
     114:	39400803 	ldrb	w3, [x0, #2]
     118:	aa034043 	orr	x3, x2, x3, lsl #16
     11c:	39400c02 	ldrb	w2, [x0, #3]
     120:	aa026062 	orr	x2, x3, x2, lsl #24
     124:	5281ba03 	mov	w3, #0xdd0                 	// #3536
     128:	72bdbfc3 	movk	w3, #0xedfe, lsl #16
     12c:	6b03005f 	cmp	w2, w3
     130:	540002e1 	b.ne	18c <fdt_ro_probe_+0xac>  // b.any
     134:	39405003 	ldrb	w3, [x0, #20]
     138:	39405402 	ldrb	w2, [x0, #21]
     13c:	aa022062 	orr	x2, x3, x2, lsl #8
     140:	39405803 	ldrb	w3, [x0, #22]
     144:	aa034043 	orr	x3, x2, x3, lsl #16
     148:	39405c02 	ldrb	w2, [x0, #23]
     14c:	aa026062 	orr	x2, x3, x2, lsl #24
     150:	5ac00842 	rev	w2, w2
     154:	7100045f 	cmp	w2, #0x1
     158:	54000169 	b.ls	184 <fdt_ro_probe_+0xa4>  // b.plast
     15c:	39406002 	ldrb	w2, [x0, #24]
     160:	39406403 	ldrb	w3, [x0, #25]
     164:	aa032043 	orr	x3, x2, x3, lsl #8
     168:	39406802 	ldrb	w2, [x0, #26]
     16c:	39406c00 	ldrb	w0, [x0, #27]
     170:	aa024062 	orr	x2, x3, x2, lsl #16
     174:	aa006040 	orr	x0, x2, x0, lsl #24
     178:	5ac00800 	rev	w0, w0
     17c:	7100441f 	cmp	w0, #0x11
     180:	540001e9 	b.ls	1bc <fdt_ro_probe_+0xdc>  // b.plast
     184:	12800120 	mov	w0, #0xfffffff6            	// #-10
     188:	14000011 	b	1cc <fdt_ro_probe_+0xec>
     18c:	529e45e3 	mov	w3, #0xf22f                	// #61999
     190:	72a24023 	movk	w3, #0x1201, lsl #16
     194:	6b03005f 	cmp	w2, w3
     198:	54000201 	b.ne	1d8 <fdt_ro_probe_+0xf8>  // b.any
     19c:	39409002 	ldrb	w2, [x0, #36]
     1a0:	39409403 	ldrb	w3, [x0, #37]
     1a4:	aa032043 	orr	x3, x2, x3, lsl #8
     1a8:	39409802 	ldrb	w2, [x0, #38]
     1ac:	39409c00 	ldrb	w0, [x0, #39]
     1b0:	aa024062 	orr	x2, x3, x2, lsl #16
     1b4:	aa006040 	orr	x0, x2, x0, lsl #24
     1b8:	b4000140 	cbz	x0, 1e0 <fdt_ro_probe_+0x100>
     1bc:	321f77e0 	mov	w0, #0x7ffffffe            	// #2147483646
     1c0:	6b00003f 	cmp	w1, w0
     1c4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
     1c8:	1a809020 	csel	w0, w1, w0, ls	// ls = plast
     1cc:	d65f03c0 	ret
     1d0:	12800240 	mov	w0, #0xffffffed            	// #-19
     1d4:	17fffffe 	b	1cc <fdt_ro_probe_+0xec>
     1d8:	12800100 	mov	w0, #0xfffffff7            	// #-9
     1dc:	17fffffc 	b	1cc <fdt_ro_probe_+0xec>
     1e0:	128000c0 	mov	w0, #0xfffffff9            	// #-7
     1e4:	17fffffa 	b	1cc <fdt_ro_probe_+0xec>

00000000000001e8 <fdt_header_size_>:
     1e8:	7100041f 	cmp	w0, #0x1
     1ec:	54000109 	b.ls	20c <PECOFF_FILE_ALIGNMENT+0xc>  // b.plast
     1f0:	7100081f 	cmp	w0, #0x2
     1f4:	54000100 	b.eq	214 <PECOFF_FILE_ALIGNMENT+0x14>  // b.none
     1f8:	7100401f 	cmp	w0, #0x10
     1fc:	d2800481 	mov	x1, #0x24                  	// #36
     200:	d2800500 	mov	x0, #0x28                  	// #40
     204:	9a818000 	csel	x0, x0, x1, hi	// hi = pmore
     208:	d65f03c0 	ret
     20c:	d2800380 	mov	x0, #0x1c                  	// #28
     210:	17fffffe 	b	208 <PECOFF_FILE_ALIGNMENT+0x8>
     214:	d2800400 	mov	x0, #0x20                  	// #32
     218:	17fffffc 	b	208 <PECOFF_FILE_ALIGNMENT+0x8>

000000000000021c <fdt_header_size>:
     21c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
     220:	910003fd 	mov	x29, sp
     224:	39405001 	ldrb	w1, [x0, #20]
     228:	39405402 	ldrb	w2, [x0, #21]
     22c:	aa022022 	orr	x2, x1, x2, lsl #8
     230:	39405801 	ldrb	w1, [x0, #22]
     234:	39405c00 	ldrb	w0, [x0, #23]
     238:	aa014041 	orr	x1, x2, x1, lsl #16
     23c:	aa006020 	orr	x0, x1, x0, lsl #24
     240:	5ac00800 	rev	w0, w0
     244:	97ffffe9 	bl	1e8 <fdt_header_size_>
     248:	a8c17bfd 	ldp	x29, x30, [sp], #16
     24c:	d65f03c0 	ret

0000000000000250 <fdt_check_header>:
     250:	f240081f 	tst	x0, #0x7
     254:	54000ec1 	b.ne	42c <fdt_check_header+0x1dc>  // b.any
     258:	39400002 	ldrb	w2, [x0]
     25c:	aa0003e3 	mov	x3, x0
     260:	39400401 	ldrb	w1, [x0, #1]
     264:	aa012041 	orr	x1, x2, x1, lsl #8
     268:	39400802 	ldrb	w2, [x0, #2]
     26c:	aa024022 	orr	x2, x1, x2, lsl #16
     270:	39400c01 	ldrb	w1, [x0, #3]
     274:	aa016041 	orr	x1, x2, x1, lsl #24
     278:	5281ba02 	mov	w2, #0xdd0                 	// #3536
     27c:	72bdbfc2 	movk	w2, #0xedfe, lsl #16
     280:	6b02003f 	cmp	w1, w2
     284:	54000d81 	b.ne	434 <fdt_check_header+0x1e4>  // b.any
     288:	39405001 	ldrb	w1, [x0, #20]
     28c:	39405402 	ldrb	w2, [x0, #21]
     290:	39405c04 	ldrb	w4, [x0, #23]
     294:	aa022022 	orr	x2, x1, x2, lsl #8
     298:	39405801 	ldrb	w1, [x0, #22]
     29c:	aa014041 	orr	x1, x2, x1, lsl #16
     2a0:	aa046024 	orr	x4, x1, x4, lsl #24
     2a4:	5ac00884 	rev	w4, w4
     2a8:	7100049f 	cmp	w4, #0x1
     2ac:	54000c89 	b.ls	43c <fdt_check_header+0x1ec>  // b.plast
     2b0:	39406002 	ldrb	w2, [x0, #24]
     2b4:	39406401 	ldrb	w1, [x0, #25]
     2b8:	aa012041 	orr	x1, x2, x1, lsl #8
     2bc:	39406802 	ldrb	w2, [x0, #26]
     2c0:	aa024022 	orr	x2, x1, x2, lsl #16
     2c4:	39406c01 	ldrb	w1, [x0, #27]
     2c8:	aa016041 	orr	x1, x2, x1, lsl #24
     2cc:	5ac00821 	rev	w1, w1
     2d0:	7100443f 	cmp	w1, #0x11
     2d4:	54000b48 	b.hi	43c <fdt_check_header+0x1ec>  // b.pmore
     2d8:	6b01009f 	cmp	w4, w1
     2dc:	54000b03 	b.cc	43c <fdt_check_header+0x1ec>  // b.lo, b.ul, b.last
     2e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
     2e4:	910003fd 	mov	x29, sp
     2e8:	97ffffcd 	bl	21c <fdt_header_size>
     2ec:	39401062 	ldrb	w2, [x3, #4]
     2f0:	39401461 	ldrb	w1, [x3, #5]
     2f4:	aa012041 	orr	x1, x2, x1, lsl #8
     2f8:	39401862 	ldrb	w2, [x3, #6]
     2fc:	aa024022 	orr	x2, x1, x2, lsl #16
     300:	39401c61 	ldrb	w1, [x3, #7]
     304:	aa016041 	orr	x1, x2, x1, lsl #24
     308:	5ac00825 	rev	w5, w1
     30c:	5ac00821 	rev	w1, w1
     310:	eb00003f 	cmp	x1, x0
     314:	540003a3 	b.cc	388 <fdt_check_header+0x138>  // b.lo, b.ul, b.last
     318:	37f80385 	tbnz	w5, #31, 388 <fdt_check_header+0x138>
     31c:	39404062 	ldrb	w2, [x3, #16]
     320:	39404461 	ldrb	w1, [x3, #17]
     324:	aa012041 	orr	x1, x2, x1, lsl #8
     328:	39404862 	ldrb	w2, [x3, #18]
     32c:	aa024022 	orr	x2, x1, x2, lsl #16
     330:	39404c61 	ldrb	w1, [x3, #19]
     334:	aa016041 	orr	x1, x2, x1, lsl #24
     338:	5ac00821 	rev	w1, w1
     33c:	6b01001f 	cmp	w0, w1
     340:	7a4190a0 	ccmp	w5, w1, #0x0, ls	// ls = plast
     344:	54000223 	b.cc	388 <fdt_check_header+0x138>  // b.lo, b.ul, b.last
     348:	39402061 	ldrb	w1, [x3, #8]
     34c:	39402462 	ldrb	w2, [x3, #9]
     350:	aa022022 	orr	x2, x1, x2, lsl #8
     354:	39402861 	ldrb	w1, [x3, #10]
     358:	aa014041 	orr	x1, x2, x1, lsl #16
     35c:	39402c62 	ldrb	w2, [x3, #11]
     360:	aa026022 	orr	x2, x1, x2, lsl #24
     364:	5ac00842 	rev	w2, w2
     368:	6b02001f 	cmp	w0, w2
     36c:	1a9f87e1 	cset	w1, ls	// ls = plast
     370:	6b0200bf 	cmp	w5, w2
     374:	1a9f37e6 	cset	w6, cs	// cs = hs, nlast
     378:	7100409f 	cmp	w4, #0x10
     37c:	0a060021 	and	w1, w1, w6
     380:	54000088 	b.hi	390 <fdt_check_header+0x140>  // b.pmore
     384:	35000201 	cbnz	w1, 3c4 <fdt_check_header+0x174>
     388:	128000e0 	mov	w0, #0xfffffff8            	// #-8
     38c:	14000026 	b	424 <fdt_check_header+0x1d4>
     390:	34ffffc1 	cbz	w1, 388 <fdt_check_header+0x138>
     394:	39409064 	ldrb	w4, [x3, #36]
     398:	39409461 	ldrb	w1, [x3, #37]
     39c:	aa012081 	orr	x1, x4, x1, lsl #8
     3a0:	39409864 	ldrb	w4, [x3, #38]
     3a4:	aa044024 	orr	x4, x1, x4, lsl #16
     3a8:	39409c61 	ldrb	w1, [x3, #39]
     3ac:	aa016081 	orr	x1, x4, x1, lsl #24
     3b0:	5ac00821 	rev	w1, w1
     3b4:	2b020021 	adds	w1, w1, w2
     3b8:	54fffe82 	b.cs	388 <fdt_check_header+0x138>  // b.hs, b.nlast
     3bc:	6b0100bf 	cmp	w5, w1
     3c0:	54fffe43 	b.cc	388 <fdt_check_header+0x138>  // b.lo, b.ul, b.last
     3c4:	39403062 	ldrb	w2, [x3, #12]
     3c8:	39403461 	ldrb	w1, [x3, #13]
     3cc:	aa012041 	orr	x1, x2, x1, lsl #8
     3d0:	39403862 	ldrb	w2, [x3, #14]
     3d4:	aa024022 	orr	x2, x1, x2, lsl #16
     3d8:	39403c61 	ldrb	w1, [x3, #15]
     3dc:	aa016041 	orr	x1, x2, x1, lsl #24
     3e0:	5ac00821 	rev	w1, w1
     3e4:	6b01001f 	cmp	w0, w1
     3e8:	7a4190a0 	ccmp	w5, w1, #0x0, ls	// ls = plast
     3ec:	54fffce3 	b.cc	388 <fdt_check_header+0x138>  // b.lo, b.ul, b.last
     3f0:	39408062 	ldrb	w2, [x3, #32]
     3f4:	39408460 	ldrb	w0, [x3, #33]
     3f8:	aa002040 	orr	x0, x2, x0, lsl #8
     3fc:	39408862 	ldrb	w2, [x3, #34]
     400:	aa024002 	orr	x2, x0, x2, lsl #16
     404:	39408c60 	ldrb	w0, [x3, #35]
     408:	aa006040 	orr	x0, x2, x0, lsl #24
     40c:	5ac00800 	rev	w0, w0
     410:	2b000021 	adds	w1, w1, w0
     414:	54fffba2 	b.cs	388 <fdt_check_header+0x138>  // b.hs, b.nlast
     418:	6b0100bf 	cmp	w5, w1
     41c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
     420:	1a9f3000 	csel	w0, w0, wzr, cc	// cc = lo, ul, last
     424:	a8c17bfd 	ldp	x29, x30, [sp], #16
     428:	d65f03c0 	ret
     42c:	12800240 	mov	w0, #0xffffffed            	// #-19
     430:	d65f03c0 	ret
     434:	12800100 	mov	w0, #0xfffffff7            	// #-9
     438:	d65f03c0 	ret
     43c:	12800120 	mov	w0, #0xfffffff6            	// #-10
     440:	d65f03c0 	ret

0000000000000444 <fdt_offset_ptr>:
     444:	39402004 	ldrb	w4, [x0, #8]
     448:	39402403 	ldrb	w3, [x0, #9]
     44c:	aa032083 	orr	x3, x4, x3, lsl #8
     450:	39402804 	ldrb	w4, [x0, #10]
     454:	aa044064 	orr	x4, x3, x4, lsl #16
     458:	39402c03 	ldrb	w3, [x0, #11]
     45c:	aa036083 	orr	x3, x4, x3, lsl #24
     460:	5ac00863 	rev	w3, w3
     464:	2b030024 	adds	w4, w1, w3
     468:	1a9f37e5 	cset	w5, cs	// cs = hs, nlast
     46c:	37f801c1 	tbnz	w1, #31, 4a4 <fdt_offset_ptr+0x60>
     470:	350001a5 	cbnz	w5, 4a4 <fdt_offset_ptr+0x60>
     474:	2b020085 	adds	w5, w4, w2
     478:	54000162 	b.cs	4a4 <fdt_offset_ptr+0x60>  // b.hs, b.nlast
     47c:	39401006 	ldrb	w6, [x0, #4]
     480:	39401404 	ldrb	w4, [x0, #5]
     484:	aa0420c4 	orr	x4, x6, x4, lsl #8
     488:	39401806 	ldrb	w6, [x0, #6]
     48c:	aa064086 	orr	x6, x4, x6, lsl #16
     490:	39401c04 	ldrb	w4, [x0, #7]
     494:	aa0460c4 	orr	x4, x6, x4, lsl #24
     498:	5ac00884 	rev	w4, w4
     49c:	6b0400bf 	cmp	w5, w4
     4a0:	54000069 	b.ls	4ac <fdt_offset_ptr+0x68>  // b.plast
     4a4:	d2800000 	mov	x0, #0x0                   	// #0
     4a8:	1400001a 	b	510 <fdt_offset_ptr+0xcc>
     4ac:	39405005 	ldrb	w5, [x0, #20]
     4b0:	39405404 	ldrb	w4, [x0, #21]
     4b4:	aa0420a4 	orr	x4, x5, x4, lsl #8
     4b8:	39405805 	ldrb	w5, [x0, #22]
     4bc:	aa054085 	orr	x5, x4, x5, lsl #16
     4c0:	39405c04 	ldrb	w4, [x0, #23]
     4c4:	aa0460a4 	orr	x4, x5, x4, lsl #24
     4c8:	5ac00884 	rev	w4, w4
     4cc:	7100409f 	cmp	w4, #0x10
     4d0:	540001a9 	b.ls	504 <fdt_offset_ptr+0xc0>  // b.plast
     4d4:	2b020022 	adds	w2, w1, w2
     4d8:	54fffe62 	b.cs	4a4 <fdt_offset_ptr+0x60>  // b.hs, b.nlast
     4dc:	39409005 	ldrb	w5, [x0, #36]
     4e0:	39409404 	ldrb	w4, [x0, #37]
     4e4:	aa0420a4 	orr	x4, x5, x4, lsl #8
     4e8:	39409805 	ldrb	w5, [x0, #38]
     4ec:	aa054085 	orr	x5, x4, x5, lsl #16
     4f0:	39409c04 	ldrb	w4, [x0, #39]
     4f4:	aa0460a4 	orr	x4, x5, x4, lsl #24
     4f8:	5ac00884 	rev	w4, w4
     4fc:	6b04005f 	cmp	w2, w4
     500:	54fffd28 	b.hi	4a4 <fdt_offset_ptr+0x60>  // b.pmore
const char *fdt_find_string_(const char *strtab, int tabsize, const char *s);
int fdt_node_end_offset_(void *fdt, int nodeoffset);

static inline const void *fdt_offset_ptr_(const void *fdt, int offset)
{
	return (const char *)fdt + fdt_off_dt_struct(fdt) + offset;
     504:	93407c21 	sxtw	x1, w1
     508:	8b234023 	add	x3, x1, w3, uxtw
     50c:	8b030000 	add	x0, x0, x3
		if (((uoffset + len) < uoffset)
		    || ((offset + len) > fdt_size_dt_struct(fdt)))
			return NULL;

	return fdt_offset_ptr_(fdt, offset);
}
     510:	d65f03c0 	ret

0000000000000514 <fdt_next_tag>:
     514:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
     518:	aa0203ea 	mov	x10, x2
     51c:	128000e2 	mov	w2, #0xfffffff8            	// #-8
     520:	910003fd 	mov	x29, sp
     524:	b9000142 	str	w2, [x10]
     528:	aa0003e9 	mov	x9, x0
     52c:	2a0103eb 	mov	w11, w1
     530:	52800082 	mov	w2, #0x4                   	// #4
     534:	97ffffc4 	bl	444 <fdt_offset_ptr>
     538:	b40001a0 	cbz	x0, 56c <fdt_next_tag+0x58>
#define __arch_swab16 __arch_swab16

static inline __attribute_const__ __u32 __arch_swab32(__u32 x)
{
#if __LINUX_ARM_ARCH__ == 8
	__asm__ ("rev %w0, %w1" : "=r" (x) : "r" (x));
     53c:	b9400008 	ldr	w8, [x0]
	if (!can_assume(VALID_DTB) && !tagp)
		return FDT_END; /* premature end */
	tag = fdt32_to_cpu(*tagp);
	offset += FDT_TAGSIZE;

	*nextoffset = -FDT_ERR_BADSTRUCTURE;
     540:	12800140 	mov	w0, #0xfffffff5            	// #-11
     544:	b9000140 	str	w0, [x10]
	offset += FDT_TAGSIZE;
     548:	11001167 	add	w7, w11, #0x4
     54c:	5ac00908 	rev	w8, w8
	switch (tag) {
     550:	71000d1f 	cmp	w8, #0x3
     554:	540003e0 	b.eq	5d0 <fdt_next_tag+0xbc>  // b.none
     558:	54000128 	b.hi	57c <fdt_next_tag+0x68>  // b.pmore
     55c:	7100051f 	cmp	w8, #0x1
     560:	54000160 	b.eq	58c <fdt_next_tag+0x78>  // b.none
     564:	7100091f 	cmp	w8, #0x2
     568:	54000220 	b.eq	5ac <fdt_next_tag+0x98>  // b.none
		return FDT_END; /* premature end */
     56c:	52800128 	mov	w8, #0x9                   	// #9
	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
		return FDT_END; /* premature end */

	*nextoffset = FDT_TAGALIGN(offset);
	return tag;
}
     570:	2a0803e0 	mov	w0, w8
     574:	a8c17bfd 	ldp	x29, x30, [sp], #16
     578:	d65f03c0 	ret
	switch (tag) {
     57c:	7100111f 	cmp	w8, #0x4
     580:	54000160 	b.eq	5ac <fdt_next_tag+0x98>  // b.none
     584:	7100251f 	cmp	w8, #0x9
     588:	17fffff8 	b	568 <fdt_next_tag+0x54>
			p = fdt_offset_ptr(fdt, offset++, 1);
     58c:	2a0703e1 	mov	w1, w7
     590:	52800022 	mov	w2, #0x1                   	// #1
     594:	aa0903e0 	mov	x0, x9
     598:	0b0200e7 	add	w7, w7, w2
     59c:	97ffffaa 	bl	444 <fdt_offset_ptr>
		} while (p && (*p != '\0'));
     5a0:	b4fffe60 	cbz	x0, 56c <fdt_next_tag+0x58>
     5a4:	39400000 	ldrb	w0, [x0]
     5a8:	35ffff20 	cbnz	w0, 58c <fdt_next_tag+0x78>
	if (!fdt_offset_ptr(fdt, startoffset, offset - startoffset))
     5ac:	4b0b00e2 	sub	w2, w7, w11
     5b0:	2a0b03e1 	mov	w1, w11
     5b4:	aa0903e0 	mov	x0, x9
     5b8:	97ffffa3 	bl	444 <fdt_offset_ptr>
     5bc:	b4fffd80 	cbz	x0, 56c <fdt_next_tag+0x58>
	*nextoffset = FDT_TAGALIGN(offset);
     5c0:	11000ce7 	add	w7, w7, #0x3
     5c4:	121e74e7 	and	w7, w7, #0xfffffffc
     5c8:	b9000147 	str	w7, [x10]
	return tag;
     5cc:	17ffffe9 	b	570 <fdt_next_tag+0x5c>
		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
     5d0:	2a0703e1 	mov	w1, w7
     5d4:	aa0903e0 	mov	x0, x9
     5d8:	52800082 	mov	w2, #0x4                   	// #4
     5dc:	97ffff9a 	bl	444 <fdt_offset_ptr>
		if (!can_assume(VALID_DTB) && !lenp)
     5e0:	b4fffc60 	cbz	x0, 56c <fdt_next_tag+0x58>
     5e4:	b9400000 	ldr	w0, [x0]
		if (!can_assume(VALID_DTB) &&
     5e8:	321f77e1 	mov	w1, #0x7ffffffe            	// #2147483646
     5ec:	5ac00800 	rev	w0, w0
		sum = len + offset;
     5f0:	2b0000e2 	adds	w2, w7, w0
		if (!can_assume(VALID_DTB) &&
     5f4:	7a413042 	ccmp	w2, w1, #0x2, cc	// cc = lo, ul, last
     5f8:	54fffba8 	b.hi	56c <fdt_next_tag+0x58>  // b.pmore
		offset += sizeof(struct fdt_property) - FDT_TAGSIZE + len;
     5fc:	39405123 	ldrb	w3, [x9, #20]
     600:	11002047 	add	w7, w2, #0x8
		if (!can_assume(LATEST) &&
     604:	39405521 	ldrb	w1, [x9, #21]
     608:	aa012061 	orr	x1, x3, x1, lsl #8
     60c:	39405923 	ldrb	w3, [x9, #22]
     610:	aa034023 	orr	x3, x1, x3, lsl #16
     614:	39405d21 	ldrb	w1, [x9, #23]
     618:	aa016061 	orr	x1, x3, x1, lsl #24
     61c:	5ac00821 	rev	w1, w1
     620:	71003c3f 	cmp	w1, #0xf
     624:	54fffc48 	b.hi	5ac <fdt_next_tag+0x98>  // b.pmore
		    fdt_version(fdt) < 0x10 && len >= 8 &&
     628:	71001c1f 	cmp	w0, #0x7
     62c:	54fffc09 	b.ls	5ac <fdt_next_tag+0x98>  // b.plast
		    ((offset - len) % 8) != 0)
     630:	4b0000e0 	sub	w0, w7, w0
		    fdt_version(fdt) < 0x10 && len >= 8 &&
     634:	f240081f 	tst	x0, #0x7
     638:	54fffba0 	b.eq	5ac <fdt_next_tag+0x98>  // b.none
			offset += 4;
     63c:	11003047 	add	w7, w2, #0xc
     640:	17ffffdb 	b	5ac <fdt_next_tag+0x98>

0000000000000644 <fdt_check_node_offset_>:
     644:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     648:	910003fd 	mov	x29, sp
     64c:	b9001fe1 	str	w1, [sp, #28]
     650:	36f80081 	tbz	w1, #31, 660 <fdt_check_node_offset_+0x1c>
     654:	12800060 	mov	w0, #0xfffffffc            	// #-4
     658:	a8c27bfd 	ldp	x29, x30, [sp], #32
     65c:	d65f03c0 	ret
     660:	2a0103e2 	mov	w2, w1
     664:	f240045f 	tst	x2, #0x3
     668:	54ffff61 	b.ne	654 <fdt_check_node_offset_+0x10>  // b.any
     66c:	910073e2 	add	x2, sp, #0x1c
     670:	97ffffa9 	bl	514 <fdt_next_tag>
     674:	7100041f 	cmp	w0, #0x1
     678:	54fffee1 	b.ne	654 <fdt_check_node_offset_+0x10>  // b.any
     67c:	b9401fe0 	ldr	w0, [sp, #28]
     680:	17fffff6 	b	658 <fdt_check_node_offset_+0x14>

0000000000000684 <fdt_check_prop_offset_>:
     684:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     688:	910003fd 	mov	x29, sp
     68c:	b9001fe1 	str	w1, [sp, #28]
     690:	36f80081 	tbz	w1, #31, 6a0 <fdt_check_prop_offset_+0x1c>
     694:	12800060 	mov	w0, #0xfffffffc            	// #-4
     698:	a8c27bfd 	ldp	x29, x30, [sp], #32
     69c:	d65f03c0 	ret
     6a0:	2a0103e2 	mov	w2, w1
     6a4:	f240045f 	tst	x2, #0x3
     6a8:	54ffff61 	b.ne	694 <fdt_check_prop_offset_+0x10>  // b.any
     6ac:	910073e2 	add	x2, sp, #0x1c
     6b0:	97ffff99 	bl	514 <fdt_next_tag>
     6b4:	71000c1f 	cmp	w0, #0x3
     6b8:	54fffee1 	b.ne	694 <fdt_check_prop_offset_+0x10>  // b.any
     6bc:	b9401fe0 	ldr	w0, [sp, #28]
     6c0:	17fffff6 	b	698 <fdt_check_prop_offset_+0x14>

00000000000006c4 <fdt_next_node>:
     6c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     6c8:	aa0003ee 	mov	x14, x0
     6cc:	aa0203ed 	mov	x13, x2
     6d0:	910003fd 	mov	x29, sp
     6d4:	b9001fff 	str	wzr, [sp, #28]
     6d8:	36f80241 	tbz	w1, #31, 720 <fdt_next_node+0x5c>
     6dc:	910073ef 	add	x15, sp, #0x1c
     6e0:	b9401fec 	ldr	w12, [sp, #28]
     6e4:	aa0f03e2 	mov	x2, x15
     6e8:	aa0e03e0 	mov	x0, x14
     6ec:	2a0c03e1 	mov	w1, w12
     6f0:	97ffff89 	bl	514 <fdt_next_tag>
     6f4:	7100081f 	cmp	w0, #0x2
     6f8:	54000220 	b.eq	73c <fdt_next_node+0x78>  // b.none
     6fc:	7100241f 	cmp	w0, #0x9
     700:	540002c0 	b.eq	758 <fdt_next_node+0x94>  // b.none
     704:	7100041f 	cmp	w0, #0x1
     708:	54fffec1 	b.ne	6e0 <fdt_next_node+0x1c>  // b.any
     70c:	b400012d 	cbz	x13, 730 <fdt_next_node+0x6c>
     710:	b94001a0 	ldr	w0, [x13]
     714:	11000400 	add	w0, w0, #0x1
     718:	b90001a0 	str	w0, [x13]
     71c:	14000005 	b	730 <fdt_next_node+0x6c>
     720:	97ffffc9 	bl	644 <fdt_check_node_offset_>
     724:	b9001fe0 	str	w0, [sp, #28]
     728:	2a0003ec 	mov	w12, w0
     72c:	36fffd80 	tbz	w0, #31, 6dc <fdt_next_node+0x18>
     730:	2a0c03e0 	mov	w0, w12
     734:	a8c27bfd 	ldp	x29, x30, [sp], #32
     738:	d65f03c0 	ret
     73c:	b4fffd2d 	cbz	x13, 6e0 <fdt_next_node+0x1c>
     740:	b94001a1 	ldr	w1, [x13]
     744:	51000421 	sub	w1, w1, #0x1
     748:	b90001a1 	str	w1, [x13]
     74c:	36fffca1 	tbz	w1, #31, 6e0 <fdt_next_node+0x1c>
     750:	b9401fec 	ldr	w12, [sp, #28]
     754:	17fffff7 	b	730 <fdt_next_node+0x6c>
     758:	b9401fec 	ldr	w12, [sp, #28]
     75c:	36f800cc 	tbz	w12, #31, 774 <fdt_next_node+0xb0>
     760:	3100219f 	cmn	w12, #0x8
     764:	54fffe61 	b.ne	730 <fdt_next_node+0x6c>  // b.any
     768:	f10001bf 	cmp	x13, #0x0
     76c:	5a9f118c 	csinv	w12, w12, wzr, ne	// ne = any
     770:	17fffff0 	b	730 <fdt_next_node+0x6c>
     774:	1280000c 	mov	w12, #0xffffffff            	// #-1
     778:	17ffffee 	b	730 <fdt_next_node+0x6c>

000000000000077c <fdt_cells>:
     77c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     780:	910003fd 	mov	x29, sp
     784:	910073e3 	add	x3, sp, #0x1c
     788:	b9001fff 	str	wzr, [sp, #28]
     78c:	940001ae 	bl	e44 <fdt_getprop>
     790:	aa0003e1 	mov	x1, x0
     794:	b9401fe0 	ldr	w0, [sp, #28]
     798:	b4000101 	cbz	x1, 7b8 <fdt_cells+0x3c>
     79c:	7100101f 	cmp	w0, #0x4
     7a0:	54000101 	b.ne	7c0 <fdt_cells+0x44>  // b.any
     7a4:	b9400020 	ldr	w0, [x1]
	return (int)val;
     7a8:	128001a1 	mov	w1, #0xfffffff2            	// #-14
     7ac:	5ac00800 	rev	w0, w0
     7b0:	7100101f 	cmp	w0, #0x4
     7b4:	1a819000 	csel	w0, w0, w1, ls	// ls = plast
}
     7b8:	a8c27bfd 	ldp	x29, x30, [sp], #32
     7bc:	d65f03c0 	ret
		return -FDT_ERR_BADNCELLS;
     7c0:	128001a0 	mov	w0, #0xfffffff2            	// #-14
     7c4:	17fffffd 	b	7b8 <fdt_cells+0x3c>

00000000000007c8 <fdt_address_cells>:
     7c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
     7cc:	f0000002 	adrp	x2, 3000 <lz4_decompress+0x324>
     7d0:	91244042 	add	x2, x2, #0x910
     7d4:	910003fd 	mov	x29, sp
     7d8:	97ffffe9 	bl	77c <fdt_cells>
     7dc:	340000a0 	cbz	w0, 7f0 <fdt_address_cells+0x28>
     7e0:	3100041f 	cmn	w0, #0x1
     7e4:	54000081 	b.ne	7f4 <fdt_address_cells+0x2c>  // b.any
     7e8:	52800040 	mov	w0, #0x2                   	// #2
     7ec:	14000002 	b	7f4 <fdt_address_cells+0x2c>
     7f0:	128001a0 	mov	w0, #0xfffffff2            	// #-14
     7f4:	a8c17bfd 	ldp	x29, x30, [sp], #16
     7f8:	d65f03c0 	ret

00000000000007fc <fdt_size_cells>:
     7fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
     800:	f0000002 	adrp	x2, 3000 <lz4_decompress+0x324>
     804:	91247c42 	add	x2, x2, #0x91f
     808:	910003fd 	mov	x29, sp
     80c:	97ffffdc 	bl	77c <fdt_cells>
     810:	3100041f 	cmn	w0, #0x1
     814:	54000041 	b.ne	81c <fdt_size_cells+0x20>  // b.any
     818:	52800020 	mov	w0, #0x1                   	// #1
     81c:	a8c17bfd 	ldp	x29, x30, [sp], #16
     820:	d65f03c0 	ret

0000000000000824 <nextprop_>:
     824:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
     828:	910003fd 	mov	x29, sp
     82c:	a90153f3 	stp	x19, x20, [sp, #16]
     830:	aa0003f4 	mov	x20, x0
     834:	2a0103f3 	mov	w19, w1
     838:	f90013f5 	str	x21, [sp, #32]
     83c:	9100f3f5 	add	x21, sp, #0x3c
     840:	b9003fff 	str	wzr, [sp, #60]
     844:	aa1503e2 	mov	x2, x21
     848:	2a1303e1 	mov	w1, w19
     84c:	aa1403e0 	mov	x0, x20
     850:	97ffff31 	bl	514 <fdt_next_tag>
     854:	71000c1f 	cmp	w0, #0x3
     858:	540000e0 	b.eq	874 <nextprop_+0x50>  // b.none
     85c:	b9403ff3 	ldr	w19, [sp, #60]
     860:	7100241f 	cmp	w0, #0x9
     864:	54000121 	b.ne	888 <nextprop_+0x64>  // b.any
     868:	7100027f 	cmp	w19, #0x0
     86c:	12800140 	mov	w0, #0xfffffff5            	// #-11
     870:	1a80b273 	csel	w19, w19, w0, lt	// lt = tstop
     874:	f94013f5 	ldr	x21, [sp, #32]
     878:	2a1303e0 	mov	w0, w19
     87c:	a94153f3 	ldp	x19, x20, [sp, #16]
     880:	a8c47bfd 	ldp	x29, x30, [sp], #64
     884:	d65f03c0 	ret
     888:	7100101f 	cmp	w0, #0x4
     88c:	54fffdc0 	b.eq	844 <nextprop_+0x20>  // b.none
     890:	12800013 	mov	w19, #0xffffffff            	// #-1
     894:	17fffff8 	b	874 <nextprop_+0x50>

0000000000000898 <fdt_get_property_by_offset_>:
     898:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
     89c:	910003fd 	mov	x29, sp
     8a0:	a90153f3 	stp	x19, x20, [sp, #16]
     8a4:	aa0003f3 	mov	x19, x0
     8a8:	aa0203f4 	mov	x20, x2
     8ac:	f90013f5 	str	x21, [sp, #32]
     8b0:	2a0103f5 	mov	w21, w1
     8b4:	97ffff74 	bl	684 <fdt_check_prop_offset_>
     8b8:	36f80100 	tbz	w0, #31, 8d8 <fdt_get_property_by_offset_+0x40>
     8bc:	b4000054 	cbz	x20, 8c4 <fdt_get_property_by_offset_+0x2c>
     8c0:	b9000280 	str	w0, [x20]
     8c4:	d2800000 	mov	x0, #0x0                   	// #0
     8c8:	a94153f3 	ldp	x19, x20, [sp, #16]
     8cc:	f94013f5 	ldr	x21, [sp, #32]
     8d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
     8d4:	d65f03c0 	ret
     8d8:	39402261 	ldrb	w1, [x19, #8]
     8dc:	39402660 	ldrb	w0, [x19, #9]
     8e0:	aa002020 	orr	x0, x1, x0, lsl #8
     8e4:	39402a61 	ldrb	w1, [x19, #10]
     8e8:	aa014001 	orr	x1, x0, x1, lsl #16
     8ec:	39402e60 	ldrb	w0, [x19, #11]
     8f0:	aa006020 	orr	x0, x1, x0, lsl #24
     8f4:	5ac00800 	rev	w0, w0
     8f8:	8b35c015 	add	x21, x0, w21, sxtw
     8fc:	8b150260 	add	x0, x19, x21
		return NULL;
	}

	prop = fdt_offset_ptr_(fdt, offset);

	if (lenp)
     900:	b4fffe54 	cbz	x20, 8c8 <fdt_get_property_by_offset_+0x30>
     904:	b9400401 	ldr	w1, [x0, #4]
     908:	5ac00821 	rev	w1, w1
		*lenp = fdt32_ld_(&prop->len);
     90c:	b9000281 	str	w1, [x20]
     910:	17ffffee 	b	8c8 <fdt_get_property_by_offset_+0x30>

0000000000000914 <fdt_get_string>:
     914:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
     918:	910003fd 	mov	x29, sp
     91c:	a90153f3 	stp	x19, x20, [sp, #16]
     920:	aa0003f3 	mov	x19, x0
     924:	aa0203f4 	mov	x20, x2
     928:	f90013f5 	str	x21, [sp, #32]
     92c:	2a0103f5 	mov	w21, w1
     930:	97fffdec 	bl	e0 <fdt_ro_probe_>
     934:	37f80a60 	tbnz	w0, #31, a80 <fdt_get_string+0x16c>
     938:	39403261 	ldrb	w1, [x19, #12]
     93c:	39403662 	ldrb	w2, [x19, #13]
     940:	39403e64 	ldrb	w4, [x19, #15]
     944:	aa022022 	orr	x2, x1, x2, lsl #8
     948:	39403a61 	ldrb	w1, [x19, #14]
     94c:	aa014041 	orr	x1, x2, x1, lsl #16
     950:	aa046024 	orr	x4, x1, x4, lsl #24
     954:	5ac00884 	rev	w4, w4
     958:	0b0402a4 	add	w4, w21, w4
     95c:	6b04001f 	cmp	w0, w4
     960:	54000969 	b.ls	a8c <fdt_get_string+0x178>  // b.plast
     964:	39400262 	ldrb	w2, [x19]
     968:	4b040000 	sub	w0, w0, w4
     96c:	39400661 	ldrb	w1, [x19, #1]
     970:	aa012041 	orr	x1, x2, x1, lsl #8
     974:	39400a62 	ldrb	w2, [x19, #2]
     978:	aa024022 	orr	x2, x1, x2, lsl #16
     97c:	39400e61 	ldrb	w1, [x19, #3]
     980:	aa016041 	orr	x1, x2, x1, lsl #24
     984:	5281ba02 	mov	w2, #0xdd0                 	// #3536
     988:	72bdbfc2 	movk	w2, #0xedfe, lsl #16
     98c:	6b02003f 	cmp	w1, w2
     990:	54000501 	b.ne	a30 <fdt_get_string+0x11c>  // b.any
     994:	37f807d5 	tbnz	w21, #31, a8c <fdt_get_string+0x178>
     998:	39405261 	ldrb	w1, [x19, #20]
     99c:	39405662 	ldrb	w2, [x19, #21]
     9a0:	39405e63 	ldrb	w3, [x19, #23]
     9a4:	aa022022 	orr	x2, x1, x2, lsl #8
     9a8:	39405a61 	ldrb	w1, [x19, #22]
     9ac:	aa014041 	orr	x1, x2, x1, lsl #16
     9b0:	aa036023 	orr	x3, x1, x3, lsl #24
     9b4:	5ac00863 	rev	w3, w3
     9b8:	7100407f 	cmp	w3, #0x10
     9bc:	540001e8 	b.hi	9f8 <fdt_get_string+0xe4>  // b.pmore
     9c0:	2a0003e2 	mov	w2, w0
     9c4:	8b244273 	add	x19, x19, w4, uxtw
     9c8:	52800001 	mov	w1, #0x0                   	// #0
     9cc:	aa1303e0 	mov	x0, x19
     9d0:	94000ba1 	bl	3854 <memchr>
     9d4:	b4000600 	cbz	x0, a94 <fdt_get_string+0x180>
     9d8:	b4000074 	cbz	x20, 9e4 <fdt_get_string+0xd0>
     9dc:	cb130000 	sub	x0, x0, x19
     9e0:	b9000280 	str	w0, [x20]
     9e4:	f94013f5 	ldr	x21, [sp, #32]
     9e8:	aa1303e0 	mov	x0, x19
     9ec:	a94153f3 	ldp	x19, x20, [sp, #16]
     9f0:	a8c37bfd 	ldp	x29, x30, [sp], #48
     9f4:	d65f03c0 	ret
     9f8:	39408261 	ldrb	w1, [x19, #32]
     9fc:	39408662 	ldrb	w2, [x19, #33]
     a00:	39408e63 	ldrb	w3, [x19, #35]
     a04:	aa022022 	orr	x2, x1, x2, lsl #8
     a08:	39408a61 	ldrb	w1, [x19, #34]
     a0c:	aa014041 	orr	x1, x2, x1, lsl #16
     a10:	aa036023 	orr	x3, x1, x3, lsl #24
     a14:	5ac00863 	rev	w3, w3
     a18:	6b0302bf 	cmp	w21, w3
     a1c:	54000382 	b.cs	a8c <fdt_get_string+0x178>  // b.hs, b.nlast
     a20:	4b150061 	sub	w1, w3, w21
     a24:	6b00003f 	cmp	w1, w0
     a28:	1a809022 	csel	w2, w1, w0, ls	// ls = plast
     a2c:	17ffffe6 	b	9c4 <fdt_get_string+0xb0>
     a30:	529e45e2 	mov	w2, #0xf22f                	// #61999
     a34:	72a24022 	movk	w2, #0x1201, lsl #16
     a38:	6b02003f 	cmp	w1, w2
     a3c:	54000201 	b.ne	a7c <fdt_get_string+0x168>  // b.any
     a40:	4b1503e2 	neg	w2, w21
     a44:	36f80255 	tbz	w21, #31, a8c <fdt_get_string+0x178>
     a48:	39408263 	ldrb	w3, [x19, #32]
     a4c:	39408661 	ldrb	w1, [x19, #33]
     a50:	aa012061 	orr	x1, x3, x1, lsl #8
     a54:	39408a63 	ldrb	w3, [x19, #34]
     a58:	aa034023 	orr	x3, x1, x3, lsl #16
     a5c:	39408e61 	ldrb	w1, [x19, #35]
     a60:	aa016061 	orr	x1, x3, x1, lsl #24
     a64:	5ac00821 	rev	w1, w1
     a68:	6b01005f 	cmp	w2, w1
     a6c:	54000108 	b.hi	a8c <fdt_get_string+0x178>  // b.pmore
     a70:	6b02001f 	cmp	w0, w2
     a74:	1a829002 	csel	w2, w0, w2, ls	// ls = plast
     a78:	17ffffd3 	b	9c4 <fdt_get_string+0xb0>
     a7c:	12800180 	mov	w0, #0xfffffff3            	// #-13
     a80:	b50000f4 	cbnz	x20, a9c <fdt_get_string+0x188>
     a84:	d2800013 	mov	x19, #0x0                   	// #0
     a88:	17ffffd7 	b	9e4 <fdt_get_string+0xd0>
     a8c:	12800060 	mov	w0, #0xfffffffc            	// #-4
     a90:	17fffffc 	b	a80 <fdt_get_string+0x16c>
     a94:	128000e0 	mov	w0, #0xfffffff8            	// #-8
     a98:	17fffffa 	b	a80 <fdt_get_string+0x16c>
     a9c:	b9000280 	str	w0, [x20]
     aa0:	17fffff9 	b	a84 <fdt_get_string+0x170>

0000000000000aa4 <fdt_get_name>:
     aa4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
     aa8:	910003fd 	mov	x29, sp
     aac:	a90153f3 	stp	x19, x20, [sp, #16]
     ab0:	2a0103f3 	mov	w19, w1
     ab4:	aa0003f4 	mov	x20, x0
{
     ab8:	a9025bf5 	stp	x21, x22, [sp, #32]
     abc:	aa0203f5 	mov	x21, x2
     ac0:	39402001 	ldrb	w1, [x0, #8]
     ac4:	39402402 	ldrb	w2, [x0, #9]
     ac8:	39402c16 	ldrb	w22, [x0, #11]
     acc:	aa022022 	orr	x2, x1, x2, lsl #8
     ad0:	39402801 	ldrb	w1, [x0, #10]
     ad4:	aa014041 	orr	x1, x2, x1, lsl #16
     ad8:	aa166036 	orr	x22, x1, x22, lsl #24
	if (((err = fdt_ro_probe_(fdt)) < 0)
     adc:	97fffd81 	bl	e0 <fdt_ro_probe_>
     ae0:	37f80440 	tbnz	w0, #31, b68 <fdt_get_name+0xc4>
	    || ((err = fdt_check_node_offset_(fdt, nodeoffset)) < 0))
     ae4:	2a1303e1 	mov	w1, w19
     ae8:	aa1403e0 	mov	x0, x20
     aec:	97fffed6 	bl	644 <fdt_check_node_offset_>
     af0:	37f803c0 	tbnz	w0, #31, b68 <fdt_get_name+0xc4>
	nameptr = nh->name;
     af4:	39405281 	ldrb	w1, [x20, #20]
     af8:	5ac00ad6 	rev	w22, w22
     afc:	39405680 	ldrb	w0, [x20, #21]
     b00:	8b33c2d3 	add	x19, x22, w19, sxtw
     b04:	8b130293 	add	x19, x20, x19
     b08:	91001273 	add	x19, x19, #0x4
	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10) {
     b0c:	aa002020 	orr	x0, x1, x0, lsl #8
     b10:	39405a81 	ldrb	w1, [x20, #22]
     b14:	aa014001 	orr	x1, x0, x1, lsl #16
     b18:	39405e80 	ldrb	w0, [x20, #23]
     b1c:	aa006020 	orr	x0, x1, x0, lsl #24
     b20:	5ac00800 	rev	w0, w0
     b24:	71003c1f 	cmp	w0, #0xf
     b28:	540000c8 	b.hi	b40 <fdt_get_name+0x9c>  // b.pmore
		leaf = strrchr(nameptr, '/');
     b2c:	aa1303e0 	mov	x0, x19
     b30:	528005e1 	mov	w1, #0x2f                  	// #47
     b34:	94000b65 	bl	38c8 <_strrchr>
		if (leaf == NULL) {
     b38:	b4000160 	cbz	x0, b64 <fdt_get_name+0xc0>
		nameptr = leaf+1;
     b3c:	91000413 	add	x19, x0, #0x1
	if (len)
     b40:	b4000095 	cbz	x21, b50 <fdt_get_name+0xac>
		*len = strlen(nameptr);
     b44:	aa1303e0 	mov	x0, x19
     b48:	94000b2e 	bl	3800 <strlen>
     b4c:	b90002a0 	str	w0, [x21]
}
     b50:	a9425bf5 	ldp	x21, x22, [sp, #32]
     b54:	aa1303e0 	mov	x0, x19
     b58:	a94153f3 	ldp	x19, x20, [sp, #16]
     b5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
     b60:	d65f03c0 	ret
			err = -FDT_ERR_BADSTRUCTURE;
     b64:	12800140 	mov	w0, #0xfffffff5            	// #-11
	if (len)
     b68:	b5000075 	cbnz	x21, b74 <fdt_get_name+0xd0>
	return NULL;
     b6c:	d2800013 	mov	x19, #0x0                   	// #0
     b70:	17fffff8 	b	b50 <fdt_get_name+0xac>
		*len = err;
     b74:	b90002a0 	str	w0, [x21]
     b78:	17fffffd 	b	b6c <fdt_get_name+0xc8>

0000000000000b7c <fdt_subnode_offset_namelen>:
     b7c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
     b80:	910003fd 	mov	x29, sp
     b84:	a90153f3 	stp	x19, x20, [sp, #16]
     b88:	2a0103f4 	mov	w20, w1
     b8c:	a9025bf5 	stp	x21, x22, [sp, #32]
     b90:	aa0003f5 	mov	x21, x0
     b94:	aa0203f6 	mov	x22, x2
     b98:	a90363f7 	stp	x23, x24, [sp, #48]
     b9c:	2a0303f7 	mov	w23, w3
     ba0:	a9046bf9 	stp	x25, x26, [sp, #64]
     ba4:	b9005bff 	str	wzr, [sp, #88]
     ba8:	97fffd4e 	bl	e0 <fdt_ro_probe_>
     bac:	2a0003f3 	mov	w19, w0
     bb0:	37f80160 	tbnz	w0, #31, bdc <fdt_subnode_offset_namelen+0x60>
     bb4:	2a1403f3 	mov	w19, w20
     bb8:	910173f9 	add	x25, sp, #0x5c
     bbc:	93407ef8 	sxtw	x24, w23
     bc0:	910163fa 	add	x26, sp, #0x58
     bc4:	b9005bff 	str	wzr, [sp, #88]
     bc8:	b9405be0 	ldr	w0, [sp, #88]
     bcc:	2a130001 	orr	w1, w0, w19
     bd0:	36f80141 	tbz	w1, #31, bf8 <fdt_subnode_offset_namelen+0x7c>
     bd4:	7100001f 	cmp	w0, #0x0
     bd8:	5a9fa273 	csinv	w19, w19, wzr, ge	// ge = tcont
     bdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
     be0:	2a1303e0 	mov	w0, w19
     be4:	a94153f3 	ldp	x19, x20, [sp, #16]
     be8:	a94363f7 	ldp	x23, x24, [sp, #48]
     bec:	a9446bf9 	ldp	x25, x26, [sp, #64]
     bf0:	a8c67bfd 	ldp	x29, x30, [sp], #96
     bf4:	d65f03c0 	ret
     bf8:	7100041f 	cmp	w0, #0x1
     bfc:	54000321 	b.ne	c60 <fdt_subnode_offset_namelen+0xe4>  // b.any
     c00:	aa1903e2 	mov	x2, x25
     c04:	2a1303e1 	mov	w1, w19
     c08:	aa1503e0 	mov	x0, x21
     c0c:	b9005fff 	str	wzr, [sp, #92]
     c10:	97ffffa5 	bl	aa4 <fdt_get_name>
     c14:	aa0003f4 	mov	x20, x0
     c18:	b4000240 	cbz	x0, c60 <fdt_subnode_offset_namelen+0xe4>
     c1c:	b9405fe1 	ldr	w1, [sp, #92]
     c20:	6b0102ff 	cmp	w23, w1
     c24:	540001ec 	b.gt	c60 <fdt_subnode_offset_namelen+0xe4>
     c28:	aa1803e2 	mov	x2, x24
     c2c:	aa1603e1 	mov	x1, x22
     c30:	94000afb 	bl	381c <memcmp>
     c34:	35000160 	cbnz	w0, c60 <fdt_subnode_offset_namelen+0xe4>
     c38:	38786a80 	ldrb	w0, [x20, x24]
     c3c:	34fffd00 	cbz	w0, bdc <fdt_subnode_offset_namelen+0x60>
     c40:	aa1803e2 	mov	x2, x24
     c44:	aa1603e0 	mov	x0, x22
     c48:	52800801 	mov	w1, #0x40                  	// #64
     c4c:	94000b02 	bl	3854 <memchr>
     c50:	b5000080 	cbnz	x0, c60 <fdt_subnode_offset_namelen+0xe4>
     c54:	38786a80 	ldrb	w0, [x20, x24]
     c58:	7101001f 	cmp	w0, #0x40
     c5c:	54fffc00 	b.eq	bdc <fdt_subnode_offset_namelen+0x60>  // b.none
     c60:	2a1303e1 	mov	w1, w19
     c64:	aa1a03e2 	mov	x2, x26
     c68:	aa1503e0 	mov	x0, x21
     c6c:	97fffe96 	bl	6c4 <fdt_next_node>
     c70:	2a0003f3 	mov	w19, w0
     c74:	17ffffd5 	b	bc8 <fdt_subnode_offset_namelen+0x4c>

0000000000000c78 <fdt_first_property_offset>:
     c78:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     c7c:	910003fd 	mov	x29, sp
     c80:	f9000bf3 	str	x19, [sp, #16]
     c84:	aa0003f3 	mov	x19, x0
     c88:	97fffe6f 	bl	644 <fdt_check_node_offset_>
     c8c:	37f80080 	tbnz	w0, #31, c9c <fdt_first_property_offset+0x24>
     c90:	2a0003e1 	mov	w1, w0
     c94:	aa1303e0 	mov	x0, x19
     c98:	97fffee3 	bl	824 <nextprop_>
     c9c:	f9400bf3 	ldr	x19, [sp, #16]
     ca0:	a8c27bfd 	ldp	x29, x30, [sp], #32
     ca4:	d65f03c0 	ret

0000000000000ca8 <fdt_next_property_offset>:
     ca8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     cac:	910003fd 	mov	x29, sp
     cb0:	f9000bf3 	str	x19, [sp, #16]
     cb4:	aa0003f3 	mov	x19, x0
     cb8:	97fffe73 	bl	684 <fdt_check_prop_offset_>
     cbc:	37f80080 	tbnz	w0, #31, ccc <fdt_next_property_offset+0x24>
     cc0:	2a0003e1 	mov	w1, w0
     cc4:	aa1303e0 	mov	x0, x19
     cc8:	97fffed7 	bl	824 <nextprop_>
     ccc:	f9400bf3 	ldr	x19, [sp, #16]
     cd0:	a8c27bfd 	ldp	x29, x30, [sp], #32
     cd4:	d65f03c0 	ret

0000000000000cd8 <fdt_get_property_namelen_>:
     cd8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
     cdc:	910003fd 	mov	x29, sp
     ce0:	f9002bfb 	str	x27, [sp, #80]
     ce4:	93407c7b 	sxtw	x27, w3
     ce8:	a90153f3 	stp	x19, x20, [sp, #16]
     cec:	a9025bf5 	stp	x21, x22, [sp, #32]
     cf0:	aa0003f6 	mov	x22, x0
     cf4:	aa0403f5 	mov	x21, x4
     cf8:	a90363f7 	stp	x23, x24, [sp, #48]
     cfc:	aa0503f8 	mov	x24, x5
     d00:	aa1b03f7 	mov	x23, x27
     d04:	a9046bf9 	stp	x25, x26, [sp, #64]
     d08:	aa0203f9 	mov	x25, x2
     d0c:	9101b3fa 	add	x26, sp, #0x6c
     d10:	97ffffda 	bl	c78 <fdt_first_property_offset>
     d14:	2a0003f3 	mov	w19, w0
     d18:	36f80093 	tbz	w19, #31, d28 <fdt_get_property_namelen_+0x50>
     d1c:	b5000515 	cbnz	x21, dbc <fdt_get_property_namelen_+0xe4>
     d20:	d2800014 	mov	x20, #0x0                   	// #0
     d24:	1400001c 	b	d94 <fdt_get_property_namelen_+0xbc>
     d28:	aa1503e2 	mov	x2, x21
     d2c:	2a1303e1 	mov	w1, w19
     d30:	aa1603e0 	mov	x0, x22
     d34:	97fffed9 	bl	898 <fdt_get_property_by_offset_>
     d38:	aa0003f4 	mov	x20, x0
     d3c:	b40003c0 	cbz	x0, db4 <fdt_get_property_namelen_+0xdc>
     d40:	b9400a81 	ldr	w1, [x20, #8]
	const char *p = fdt_get_string(fdt, stroffset, &slen);
     d44:	aa1a03e2 	mov	x2, x26
     d48:	aa1603e0 	mov	x0, x22
	int slen;
     d4c:	b9006fff 	str	wzr, [sp, #108]
     d50:	5ac00821 	rev	w1, w1
	const char *p = fdt_get_string(fdt, stroffset, &slen);
     d54:	97fffef0 	bl	914 <fdt_get_string>
	return p && (slen == len) && (memcmp(p, s, len) == 0);
     d58:	b4000080 	cbz	x0, d68 <fdt_get_property_namelen_+0x90>
     d5c:	b9406fe1 	ldr	w1, [sp, #108]
     d60:	6b0102ff 	cmp	w23, w1
     d64:	540000c0 	b.eq	d7c <fdt_get_property_namelen_+0xa4>  // b.none
							    int *lenp,
							    int *poffset)
{
	for (offset = fdt_first_property_offset(fdt, offset);
	     (offset >= 0);
	     (offset = fdt_next_property_offset(fdt, offset))) {
     d68:	2a1303e1 	mov	w1, w19
     d6c:	aa1603e0 	mov	x0, x22
     d70:	97ffffce 	bl	ca8 <fdt_next_property_offset>
     d74:	2a0003f3 	mov	w19, w0
     d78:	17ffffe8 	b	d18 <fdt_get_property_namelen_+0x40>
	return p && (slen == len) && (memcmp(p, s, len) == 0);
     d7c:	aa1b03e2 	mov	x2, x27
     d80:	aa1903e1 	mov	x1, x25
     d84:	94000aa6 	bl	381c <memcmp>
     d88:	35ffff00 	cbnz	w0, d68 <fdt_get_property_namelen_+0x90>
			offset = -FDT_ERR_INTERNAL;
			break;
		}
		if (fdt_string_eq_(fdt, fdt32_ld_(&prop->nameoff),
				   name, namelen)) {
			if (poffset)
     d8c:	b4000058 	cbz	x24, d94 <fdt_get_property_namelen_+0xbc>
				*poffset = offset;
     d90:	b9000313 	str	w19, [x24]
	}

	if (lenp)
		*lenp = offset;
	return NULL;
}
     d94:	a9425bf5 	ldp	x21, x22, [sp, #32]
     d98:	aa1403e0 	mov	x0, x20
     d9c:	a94153f3 	ldp	x19, x20, [sp, #16]
     da0:	a94363f7 	ldp	x23, x24, [sp, #48]
     da4:	a9446bf9 	ldp	x25, x26, [sp, #64]
     da8:	f9402bfb 	ldr	x27, [sp, #80]
     dac:	a8c77bfd 	ldp	x29, x30, [sp], #112
     db0:	d65f03c0 	ret
			offset = -FDT_ERR_INTERNAL;
     db4:	12800193 	mov	w19, #0xfffffff3            	// #-13
     db8:	17ffffd9 	b	d1c <fdt_get_property_namelen_+0x44>
		*lenp = offset;
     dbc:	b90002b3 	str	w19, [x21]
     dc0:	17ffffd8 	b	d20 <fdt_get_property_namelen_+0x48>

0000000000000dc4 <fdt_getprop_namelen>:
     dc4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
     dc8:	910003fd 	mov	x29, sp
     dcc:	9100b3e5 	add	x5, sp, #0x2c
     dd0:	f9000bf3 	str	x19, [sp, #16]
     dd4:	aa0003f3 	mov	x19, x0
     dd8:	b9002fff 	str	wzr, [sp, #44]
     ddc:	97ffffbf 	bl	cd8 <fdt_get_property_namelen_>
     de0:	b4000280 	cbz	x0, e30 <fdt_getprop_namelen+0x6c>
     de4:	39405262 	ldrb	w2, [x19, #20]
     de8:	39405661 	ldrb	w1, [x19, #21]
     dec:	aa012041 	orr	x1, x2, x1, lsl #8
     df0:	39405a62 	ldrb	w2, [x19, #22]
     df4:	aa024022 	orr	x2, x1, x2, lsl #16
     df8:	39405e61 	ldrb	w1, [x19, #23]
     dfc:	aa016041 	orr	x1, x2, x1, lsl #24
     e00:	5ac00821 	rev	w1, w1
     e04:	71003c3f 	cmp	w1, #0xf
     e08:	540001a8 	b.hi	e3c <fdt_getprop_namelen+0x78>  // b.pmore
     e0c:	b9802fe1 	ldrsw	x1, [sp, #44]
     e10:	91003021 	add	x1, x1, #0xc
     e14:	f240083f 	tst	x1, #0x7
     e18:	54000120 	b.eq	e3c <fdt_getprop_namelen+0x78>  // b.none
     e1c:	b9400401 	ldr	w1, [x0, #4]
     e20:	5ac00821 	rev	w1, w1
	if (!prop)
		return NULL;

	/* Handle realignment */
	if (!can_assume(LATEST) && fdt_version(fdt) < 0x10 &&
	    (poffset + sizeof(*prop)) % 8 && fdt32_ld_(&prop->len) >= 8)
     e24:	71001c3f 	cmp	w1, #0x7
     e28:	540000a9 	b.ls	e3c <fdt_getprop_namelen+0x78>  // b.plast
		return prop->data + 4;
     e2c:	91004000 	add	x0, x0, #0x10
	return prop->data;
}
     e30:	f9400bf3 	ldr	x19, [sp, #16]
     e34:	a8c37bfd 	ldp	x29, x30, [sp], #48
     e38:	d65f03c0 	ret
	return prop->data;
     e3c:	91003000 	add	x0, x0, #0xc
     e40:	17fffffc 	b	e30 <fdt_getprop_namelen+0x6c>

0000000000000e44 <fdt_getprop>:
     e44:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
     e48:	910003fd 	mov	x29, sp
     e4c:	a90153f3 	stp	x19, x20, [sp, #16]
     e50:	aa0003f4 	mov	x20, x0
     e54:	aa0203f3 	mov	x19, x2
     e58:	aa0203e0 	mov	x0, x2
     e5c:	a9025bf5 	stp	x21, x22, [sp, #32]
     e60:	aa0303f6 	mov	x22, x3
     e64:	2a0103f5 	mov	w21, w1
     e68:	94000a66 	bl	3800 <strlen>
     e6c:	aa1603e4 	mov	x4, x22
     e70:	2a0003e3 	mov	w3, w0
     e74:	aa1303e2 	mov	x2, x19
     e78:	2a1503e1 	mov	w1, w21
     e7c:	aa1403e0 	mov	x0, x20
     e80:	97ffffd1 	bl	dc4 <fdt_getprop_namelen>
     e84:	a94153f3 	ldp	x19, x20, [sp, #16]
     e88:	a9425bf5 	ldp	x21, x22, [sp, #32]
     e8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
     e90:	d65f03c0 	ret

0000000000000e94 <fdt_get_alias_namelen>:
     e94:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
     e98:	910003fd 	mov	x29, sp
     e9c:	a90153f3 	stp	x19, x20, [sp, #16]
     ea0:	aa0103f4 	mov	x20, x1
     ea4:	aa0003f3 	mov	x19, x0
     ea8:	f0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
     eac:	9124ac21 	add	x1, x1, #0x92b
     eb0:	f90013f5 	str	x21, [sp, #32]
     eb4:	2a0203f5 	mov	w21, w2
     eb8:	9400004e 	bl	ff0 <fdt_path_offset>
     ebc:	37f80160 	tbnz	w0, #31, ee8 <fdt_get_alias_namelen+0x54>
     ec0:	2a0003e1 	mov	w1, w0
     ec4:	2a1503e3 	mov	w3, w21
     ec8:	aa1403e2 	mov	x2, x20
     ecc:	aa1303e0 	mov	x0, x19
     ed0:	d2800004 	mov	x4, #0x0                   	// #0
     ed4:	97ffffbc 	bl	dc4 <fdt_getprop_namelen>
     ed8:	a94153f3 	ldp	x19, x20, [sp, #16]
     edc:	f94013f5 	ldr	x21, [sp, #32]
     ee0:	a8c37bfd 	ldp	x29, x30, [sp], #48
     ee4:	d65f03c0 	ret
     ee8:	d2800000 	mov	x0, #0x0                   	// #0
     eec:	17fffffb 	b	ed8 <fdt_get_alias_namelen+0x44>

0000000000000ef0 <fdt_path_offset_namelen>:
     ef0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
     ef4:	910003fd 	mov	x29, sp
     ef8:	a90153f3 	stp	x19, x20, [sp, #16]
     efc:	aa0103f3 	mov	x19, x1
     f00:	a9025bf5 	stp	x21, x22, [sp, #32]
     f04:	2a0203f5 	mov	w21, w2
     f08:	f9001bf7 	str	x23, [sp, #48]
     f0c:	aa0003f7 	mov	x23, x0
     f10:	97fffc74 	bl	e0 <fdt_ro_probe_>
     f14:	2a0003f4 	mov	w20, w0
     f18:	37f80580 	tbnz	w0, #31, fc8 <fdt_path_offset_namelen+0xd8>
     f1c:	39400260 	ldrb	w0, [x19]
     f20:	93407ea2 	sxtw	x2, w21
     f24:	8b35c275 	add	x21, x19, w21, sxtw
     f28:	7100bc1f 	cmp	w0, #0x2f
     f2c:	540005a0 	b.eq	fe0 <fdt_path_offset_namelen+0xf0>  // b.none
     f30:	528005e1 	mov	w1, #0x2f                  	// #47
     f34:	aa1303e0 	mov	x0, x19
     f38:	94000a47 	bl	3854 <memchr>
     f3c:	f100001f 	cmp	x0, #0x0
     f40:	9a951016 	csel	x22, x0, x21, ne	// ne = any
     f44:	aa1303e1 	mov	x1, x19
     f48:	4b1302c2 	sub	w2, w22, w19
     f4c:	aa1703e0 	mov	x0, x23
     f50:	97ffffd1 	bl	e94 <fdt_get_alias_namelen>
     f54:	aa0003e1 	mov	x1, x0
     f58:	b4000480 	cbz	x0, fe8 <fdt_path_offset_namelen+0xf8>
     f5c:	aa1703e0 	mov	x0, x23
     f60:	aa1603f3 	mov	x19, x22
     f64:	94000023 	bl	ff0 <fdt_path_offset>
     f68:	2a0003f4 	mov	w20, w0
     f6c:	eb15027f 	cmp	x19, x21
     f70:	540002c2 	b.cs	fc8 <fdt_path_offset_namelen+0xd8>  // b.hs, b.nlast
     f74:	aa1303f6 	mov	x22, x19
     f78:	394002c0 	ldrb	w0, [x22]
     f7c:	7100bc1f 	cmp	w0, #0x2f
     f80:	540001e0 	b.eq	fbc <fdt_path_offset_namelen+0xcc>  // b.none
     f84:	cb1602a2 	sub	x2, x21, x22
     f88:	528005e1 	mov	w1, #0x2f                  	// #47
     f8c:	aa1603e0 	mov	x0, x22
     f90:	94000a31 	bl	3854 <memchr>
     f94:	f100001f 	cmp	x0, #0x0
     f98:	2a1403e1 	mov	w1, w20
     f9c:	9a951013 	csel	x19, x0, x21, ne	// ne = any
     fa0:	aa1603e2 	mov	x2, x22
     fa4:	4b160263 	sub	w3, w19, w22
     fa8:	aa1703e0 	mov	x0, x23
     fac:	97fffef4 	bl	b7c <fdt_subnode_offset_namelen>
     fb0:	2a0003f4 	mov	w20, w0
     fb4:	36fffdc0 	tbz	w0, #31, f6c <fdt_path_offset_namelen+0x7c>
     fb8:	14000004 	b	fc8 <fdt_path_offset_namelen+0xd8>
     fbc:	910006d6 	add	x22, x22, #0x1
     fc0:	eb1602bf 	cmp	x21, x22
     fc4:	54fffda1 	b.ne	f78 <fdt_path_offset_namelen+0x88>  // b.any
     fc8:	a9425bf5 	ldp	x21, x22, [sp, #32]
     fcc:	2a1403e0 	mov	w0, w20
     fd0:	a94153f3 	ldp	x19, x20, [sp, #16]
     fd4:	f9401bf7 	ldr	x23, [sp, #48]
     fd8:	a8c47bfd 	ldp	x29, x30, [sp], #64
     fdc:	d65f03c0 	ret
     fe0:	52800014 	mov	w20, #0x0                   	// #0
     fe4:	17ffffe2 	b	f6c <fdt_path_offset_namelen+0x7c>
     fe8:	12800094 	mov	w20, #0xfffffffb            	// #-5
     fec:	17fffff7 	b	fc8 <fdt_path_offset_namelen+0xd8>

0000000000000ff0 <fdt_path_offset>:
     ff0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
     ff4:	910003fd 	mov	x29, sp
     ff8:	a90153f3 	stp	x19, x20, [sp, #16]
     ffc:	aa0003f4 	mov	x20, x0
    1000:	aa0103f3 	mov	x19, x1
    1004:	aa0103e0 	mov	x0, x1
    1008:	940009fe 	bl	3800 <strlen>
    100c:	aa1303e1 	mov	x1, x19
    1010:	2a0003e2 	mov	w2, w0
    1014:	aa1403e0 	mov	x0, x20
    1018:	97ffffb6 	bl	ef0 <fdt_path_offset_namelen>
    101c:	a94153f3 	ldp	x19, x20, [sp, #16]
    1020:	a8c27bfd 	ldp	x29, x30, [sp], #32
    1024:	d65f03c0 	ret

0000000000001028 <fdt_node_offset_by_prop_value>:
    1028:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    102c:	910003fd 	mov	x29, sp
    1030:	a90153f3 	stp	x19, x20, [sp, #16]
    1034:	aa0003f4 	mov	x20, x0
    1038:	a9025bf5 	stp	x21, x22, [sp, #32]
    103c:	aa0203f6 	mov	x22, x2
    1040:	2a0403f5 	mov	w21, w4
    1044:	a90363f7 	stp	x23, x24, [sp, #48]
    1048:	2a0103f8 	mov	w24, w1
    104c:	aa0303f7 	mov	x23, x3
    1050:	f90023f9 	str	x25, [sp, #64]
    1054:	b9005fff 	str	wzr, [sp, #92]
    1058:	97fffc22 	bl	e0 <fdt_ro_probe_>
    105c:	2a0003f3 	mov	w19, w0
    1060:	37f80380 	tbnz	w0, #31, 10d0 <fdt_node_offset_by_prop_value+0xa8>
    1064:	2a1803e1 	mov	w1, w24
    1068:	aa1403e0 	mov	x0, x20
    106c:	d2800002 	mov	x2, #0x0                   	// #0
    1070:	910173f8 	add	x24, sp, #0x5c
    1074:	97fffd94 	bl	6c4 <fdt_next_node>
    1078:	93407eb9 	sxtw	x25, w21
    107c:	2a0003f3 	mov	w19, w0
    1080:	37f80293 	tbnz	w19, #31, 10d0 <fdt_node_offset_by_prop_value+0xa8>
    1084:	aa1803e3 	mov	x3, x24
    1088:	aa1603e2 	mov	x2, x22
    108c:	2a1303e1 	mov	w1, w19
    1090:	aa1403e0 	mov	x0, x20
    1094:	97ffff6c 	bl	e44 <fdt_getprop>
    1098:	b50000e0 	cbnz	x0, 10b4 <fdt_node_offset_by_prop_value+0x8c>
    109c:	2a1303e1 	mov	w1, w19
    10a0:	aa1403e0 	mov	x0, x20
    10a4:	d2800002 	mov	x2, #0x0                   	// #0
    10a8:	97fffd87 	bl	6c4 <fdt_next_node>
    10ac:	2a0003f3 	mov	w19, w0
    10b0:	17fffff4 	b	1080 <fdt_node_offset_by_prop_value+0x58>
    10b4:	b9405fe1 	ldr	w1, [sp, #92]
    10b8:	6b15003f 	cmp	w1, w21
    10bc:	54ffff01 	b.ne	109c <fdt_node_offset_by_prop_value+0x74>  // b.any
    10c0:	aa1903e2 	mov	x2, x25
    10c4:	aa1703e1 	mov	x1, x23
    10c8:	940009d5 	bl	381c <memcmp>
    10cc:	35fffe80 	cbnz	w0, 109c <fdt_node_offset_by_prop_value+0x74>
    10d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
    10d4:	2a1303e0 	mov	w0, w19
    10d8:	a94153f3 	ldp	x19, x20, [sp, #16]
    10dc:	a94363f7 	ldp	x23, x24, [sp, #48]
    10e0:	f94023f9 	ldr	x25, [sp, #64]
    10e4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    10e8:	d65f03c0 	ret

00000000000010ec <number>:
#define SMALL	32		/* Must be 32 == 0x20 */
#define SPECIAL	64		/* 0x */

static char *number(char *buf, const char *end, unsigned long long num, int base, int size,
		    int precision, int type)
{
    10ec:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
	/* we are called with base 8, 10 or 16, only, thus don't need "G..."  */
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
    10f0:	910163e8 	add	x8, sp, #0x58
{
    10f4:	910003fd 	mov	x29, sp
    10f8:	a90153f3 	stp	x19, x20, [sp, #16]
    10fc:	aa0003f3 	mov	x19, x0
    1100:	2a0403f4 	mov	w20, w4
	char tmp[66];
    1104:	aa0803e0 	mov	x0, x8
{
    1108:	a9025bf5 	stp	x21, x22, [sp, #32]
    110c:	aa0203f6 	mov	x22, x2
    1110:	2a0603f5 	mov	w21, w6
	char tmp[66];
    1114:	d2800842 	mov	x2, #0x42                  	// #66
{
    1118:	a90363f7 	stp	x23, x24, [sp, #48]
    111c:	aa0103f7 	mov	x23, x1
    1120:	2a0503f8 	mov	w24, w5
	char tmp[66];
    1124:	52800001 	mov	w1, #0x0                   	// #0
{
    1128:	f90023f9 	str	x25, [sp, #64]
    112c:	2a0303f9 	mov	w25, w3
	char tmp[66];
    1130:	940009d5 	bl	3884 <__memset>
    1134:	aa0003e8 	mov	x8, x0
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
    1138:	363003d5 	tbz	w21, #6, 11b0 <number+0xc4>
    113c:	71002b3f 	cmp	w25, #0xa
    1140:	1a9f07e6 	cset	w6, ne	// ne = any
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
    1144:	121b02a4 	and	w4, w21, #0x20
	if (type & LEFT)
    1148:	121c02a9 	and	w9, w21, #0x10
    114c:	36200055 	tbz	w21, #4, 1154 <number+0x68>
		type &= ~ZEROPAD;
    1150:	121f7ab5 	and	w21, w21, #0xfffffffe
	sign = 0;
	if (type & SIGN) {
    1154:	36080b15 	tbz	w21, #1, 12b4 <number+0x1c8>
		if ((signed long long) num < 0) {
    1158:	b6f80316 	tbz	x22, #63, 11b8 <number+0xcc>
			sign = '-';
			num = - (signed long long) num;
    115c:	cb1603f6 	neg	x22, x22
			size--;
    1160:	51000694 	sub	w20, w20, #0x1
			sign = '-';
    1164:	528005a1 	mov	w1, #0x2d                  	// #45
		} else if (type & SPACE) {
			sign = ' ';
			size--;
		}
	}
	if (need_pfx) {
    1168:	35000306 	cbnz	w6, 11c8 <number+0xdc>
	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
		tmp[i++] = '0';
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
    116c:	d0000005 	adrp	x5, 3000 <lz4_decompress+0x324>
    1170:	93407f23 	sxtw	x3, w25
    1174:	912dc8a5 	add	x5, x5, #0xb72
			sign = '-';
    1178:	d2800002 	mov	x2, #0x0                   	// #0
		tmp[i++] = (digits[do_div(num,base)] | locase);
    117c:	9ac30ac0 	udiv	x0, x22, x3
    1180:	aa1603e7 	mov	x7, x22
    1184:	9b03d80a 	msub	x10, x0, x3, x22
    1188:	aa0003f6 	mov	x22, x0
    118c:	386a48a0 	ldrb	w0, [x5, w10, uxtw]
    1190:	2a000080 	orr	w0, w4, w0
    1194:	38226900 	strb	w0, [x8, x2]
	} while (num != 0);
    1198:	aa0203e0 	mov	x0, x2
    119c:	91000442 	add	x2, x2, #0x1
    11a0:	eb07007f 	cmp	x3, x7
    11a4:	54fffec9 	b.ls	117c <number+0x90>  // b.plast
		tmp[i++] = (digits[do_div(num,base)] | locase);
    11a8:	11000400 	add	w0, w0, #0x1
    11ac:	1400000f 	b	11e8 <number+0xfc>
    11b0:	121a02a6 	and	w6, w21, #0x40
    11b4:	17ffffe4 	b	1144 <number+0x58>
		} else if (type & PLUS) {
    11b8:	36100775 	tbz	w21, #2, 12a4 <number+0x1b8>
			size--;
    11bc:	51000694 	sub	w20, w20, #0x1
			sign = '+';
    11c0:	52800561 	mov	w1, #0x2b                  	// #43
	if (need_pfx) {
    11c4:	340000a6 	cbz	w6, 11d8 <number+0xec>
		size--;
    11c8:	51000680 	sub	w0, w20, #0x1
    11cc:	7100433f 	cmp	w25, #0x10
    11d0:	51000a94 	sub	w20, w20, #0x2
    11d4:	1a800294 	csel	w20, w20, w0, eq	// eq = none
	if (num == 0)
    11d8:	b5fffcb6 	cbnz	x22, 116c <number+0x80>
		tmp[i++] = '0';
    11dc:	52800600 	mov	w0, #0x30                  	// #48
    11e0:	390163e0 	strb	w0, [sp, #88]
    11e4:	52800020 	mov	w0, #0x1                   	// #1

	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
    11e8:	6b18001f 	cmp	w0, w24
		precision = i;
	size -= precision;
	if (!(type & (ZEROPAD+LEFT))) {
    11ec:	52800223 	mov	w3, #0x11                  	// #17
	if (i > precision)
    11f0:	1a98a005 	csel	w5, w0, w24, ge	// ge = tcont
	size -= precision;
    11f4:	4b050282 	sub	w2, w20, w5
	if (!(type & (ZEROPAD+LEFT))) {
    11f8:	6a0302bf 	tst	w21, w3
    11fc:	54000800 	b.eq	12fc <number+0x210>  // b.none
				*buf = ' ';
			++buf;
		}
	}
	/* sign */
	if (sign) {
    1200:	340000a1 	cbz	w1, 1214 <number+0x128>
		if (buf < end)
    1204:	eb17027f 	cmp	x19, x23
    1208:	54000042 	b.cs	1210 <number+0x124>  // b.hs, b.nlast
			*buf = sign;
    120c:	39000261 	strb	w1, [x19]
		++buf;
    1210:	91000673 	add	x19, x19, #0x1
	}
	/* "0x" / "0" prefix */
	if (need_pfx) {
    1214:	340001c6 	cbz	w6, 124c <number+0x160>
		if (buf < end)
    1218:	eb17027f 	cmp	x19, x23
    121c:	54000062 	b.cs	1228 <number+0x13c>  // b.hs, b.nlast
			*buf = '0';
    1220:	52800601 	mov	w1, #0x30                  	// #48
    1224:	39000261 	strb	w1, [x19]
		++buf;
    1228:	91000661 	add	x1, x19, #0x1
		if (base == 16) {
    122c:	7100433f 	cmp	w25, #0x10
    1230:	540006e1 	b.ne	130c <number+0x220>  // b.any
			if (buf < end)
    1234:	eb0102ff 	cmp	x23, x1
    1238:	54000089 	b.ls	1248 <number+0x15c>  // b.plast
				*buf = ('X' | locase);
    123c:	52800b01 	mov	w1, #0x58                  	// #88
    1240:	2a010084 	orr	w4, w4, w1
    1244:	39000664 	strb	w4, [x19, #1]
			++buf;
    1248:	91000a73 	add	x19, x19, #0x2
		}
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
    124c:	35000249 	cbnz	w9, 1294 <number+0x1a8>
		char c = (type & ZEROPAD) ? '0' : ' ';
    1250:	52800601 	mov	w1, #0x30                  	// #48
    1254:	f24002bf 	tst	x21, #0x1
    1258:	52800404 	mov	w4, #0x20                  	// #32
		while (--size >= 0) {
    125c:	2a0203e3 	mov	w3, w2
		char c = (type & ZEROPAD) ? '0' : ' ';
    1260:	1a810084 	csel	w4, w4, w1, eq	// eq = none
		while (--size >= 0) {
    1264:	aa1303e1 	mov	x1, x19
    1268:	71000463 	subs	w3, w3, #0x1
    126c:	54000545 	b.pl	1314 <number+0x228>  // b.nfrst
    1270:	51000443 	sub	w3, w2, #0x1
    1274:	2a0203e1 	mov	w1, w2
    1278:	3100047f 	cmn	w3, #0x1
    127c:	1a9fb7e4 	cset	w4, ge	// ge = tcont
    1280:	7100009f 	cmp	w4, #0x0
    1284:	9a9f1021 	csel	x1, x1, xzr, ne	// ne = any
    1288:	5a8207e2 	csneg	w2, wzr, w2, eq	// eq = none
    128c:	8b010273 	add	x19, x19, x1
    1290:	0b020062 	add	w2, w3, w2
    1294:	2a0503e3 	mov	w3, w5
    1298:	aa1303e1 	mov	x1, x19
		}
	}
	/* hmm even more zero padding? */
	while (i <= --precision) {
		if (buf < end)
			*buf = '0';
    129c:	52800604 	mov	w4, #0x30                  	// #48
    12a0:	14000026 	b	1338 <number+0x24c>
		} else if (type & SPACE) {
    12a4:	36180095 	tbz	w21, #3, 12b4 <number+0x1c8>
			size--;
    12a8:	51000694 	sub	w20, w20, #0x1
			sign = ' ';
    12ac:	52800401 	mov	w1, #0x20                  	// #32
    12b0:	17ffffc5 	b	11c4 <number+0xd8>
	sign = 0;
    12b4:	52800001 	mov	w1, #0x0                   	// #0
    12b8:	17ffffc3 	b	11c4 <number+0xd8>
			if (buf < end)
    12bc:	eb1700ff 	cmp	x7, x23
    12c0:	54000042 	b.cs	12c8 <number+0x1dc>  // b.hs, b.nlast
				*buf = ' ';
    12c4:	390000ea 	strb	w10, [x7]
			++buf;
    12c8:	910004e7 	add	x7, x7, #0x1
		while(--size >= 0) {
    12cc:	71000463 	subs	w3, w3, #0x1
    12d0:	54ffff65 	b.pl	12bc <number+0x1d0>  // b.nfrst
    12d4:	51000443 	sub	w3, w2, #0x1
    12d8:	4b1400b4 	sub	w20, w5, w20
    12dc:	3100047f 	cmn	w3, #0x1
    12e0:	1a9fb7e7 	cset	w7, ge	// ge = tcont
    12e4:	710000ff 	cmp	w7, #0x0
    12e8:	9a9f1042 	csel	x2, x2, xzr, ne	// ne = any
    12ec:	1a9f1294 	csel	w20, w20, wzr, ne	// ne = any
    12f0:	8b020273 	add	x19, x19, x2
    12f4:	0b140062 	add	w2, w3, w20
    12f8:	17ffffc2 	b	1200 <number+0x114>
	size -= precision;
    12fc:	2a0203e3 	mov	w3, w2
    1300:	aa1303e7 	mov	x7, x19
				*buf = ' ';
    1304:	5280040a 	mov	w10, #0x20                  	// #32
    1308:	17fffff1 	b	12cc <number+0x1e0>
		++buf;
    130c:	aa0103f3 	mov	x19, x1
    1310:	17ffffcf 	b	124c <number+0x160>
			if (buf < end)
    1314:	eb17003f 	cmp	x1, x23
    1318:	54000042 	b.cs	1320 <number+0x234>  // b.hs, b.nlast
				*buf = c;
    131c:	39000024 	strb	w4, [x1]
			++buf;
    1320:	91000421 	add	x1, x1, #0x1
    1324:	17ffffd1 	b	1268 <number+0x17c>
		if (buf < end)
    1328:	eb17003f 	cmp	x1, x23
    132c:	54000042 	b.cs	1334 <number+0x248>  // b.hs, b.nlast
			*buf = '0';
    1330:	39000024 	strb	w4, [x1]
		++buf;
    1334:	91000421 	add	x1, x1, #0x1
	while (i <= --precision) {
    1338:	51000463 	sub	w3, w3, #0x1
    133c:	6b03001f 	cmp	w0, w3
    1340:	54ffff4d 	b.le	1328 <number+0x23c>
    1344:	51000403 	sub	w3, w0, #0x1
    1348:	4b0000a1 	sub	w1, w5, w0
    134c:	510004a5 	sub	w5, w5, #0x1
    1350:	6b0300bf 	cmp	w5, w3
    1354:	93407c63 	sxtw	x3, w3
    1358:	9a9fa021 	csel	x1, x1, xzr, ge	// ge = tcont
    135c:	8b010273 	add	x19, x19, x1
    1360:	aa1303e1 	mov	x1, x19
	}
	/* actual digits of result */
	while (--i >= 0) {
		if (buf < end)
    1364:	eb17003f 	cmp	x1, x23
    1368:	54000062 	b.cs	1374 <number+0x288>  // b.hs, b.nlast
			*buf = tmp[i];
    136c:	38636904 	ldrb	w4, [x8, x3]
    1370:	39000024 	strb	w4, [x1]
	while (--i >= 0) {
    1374:	d1000463 	sub	x3, x3, #0x1
		++buf;
    1378:	91000421 	add	x1, x1, #0x1
	while (--i >= 0) {
    137c:	3100047f 	cmn	w3, #0x1
    1380:	54ffff21 	b.ne	1364 <number+0x278>  // b.any
    1384:	8b204260 	add	x0, x19, w0, uxtw
    1388:	2a0203e3 	mov	w3, w2
    138c:	aa0003e1 	mov	x1, x0
	}
	/* trailing space padding */
	while (--size >= 0) {
		if (buf < end)
			*buf = ' ';
    1390:	52800404 	mov	w4, #0x20                  	// #32
	while (--size >= 0) {
    1394:	71000463 	subs	w3, w3, #0x1
    1398:	54000185 	b.pl	13c8 <number+0x2dc>  // b.nfrst
		++buf;
	}
	return buf;
    139c:	2a0203e1 	mov	w1, w2
    13a0:	51000442 	sub	w2, w2, #0x1
    13a4:	3100045f 	cmn	w2, #0x1
    13a8:	9a9fa021 	csel	x1, x1, xzr, ge	// ge = tcont
}
    13ac:	a94153f3 	ldp	x19, x20, [sp, #16]
    13b0:	8b010000 	add	x0, x0, x1
    13b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    13b8:	a94363f7 	ldp	x23, x24, [sp, #48]
    13bc:	f94023f9 	ldr	x25, [sp, #64]
    13c0:	a8ca7bfd 	ldp	x29, x30, [sp], #160
    13c4:	d65f03c0 	ret
		if (buf < end)
    13c8:	eb17003f 	cmp	x1, x23
    13cc:	54000042 	b.cs	13d4 <number+0x2e8>  // b.hs, b.nlast
			*buf = ' ';
    13d0:	39000024 	strb	w4, [x1]
		++buf;
    13d4:	91000421 	add	x1, x1, #0x1
    13d8:	17ffffef 	b	1394 <number+0x2a8>

00000000000013dc <vsnprintf>:
 *
 * Call this function if you are already dealing with a va_list.
 * You probably want snprintf() instead.
 */
int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
{
    13dc:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    13e0:	910003fd 	mov	x29, sp
    13e4:	f90037e1 	str	x1, [sp, #104]
    13e8:	a90573fb 	stp	x27, x28, [sp, #80]
    13ec:	aa0003fb 	mov	x27, x0
				/* 'z' changed to 'Z' --davidm 1/25/99 */
				/* 't' added for ptrdiff_t */

	/* Reject out-of-range values early.  Large positive sizes are
	   used for unknown buffer sizes. */
	if (unlikely((int) size < 0))
    13f0:	b9406be0 	ldr	w0, [sp, #104]
{
    13f4:	a90153f3 	stp	x19, x20, [sp, #16]
    13f8:	a9025bf5 	stp	x21, x22, [sp, #32]
    13fc:	a90363f7 	stp	x23, x24, [sp, #48]
    1400:	a9046bf9 	stp	x25, x26, [sp, #64]
    1404:	a9406867 	ldp	x7, x26, [x3]
    1408:	b9401873 	ldr	w19, [x3, #24]
	if (unlikely((int) size < 0))
    140c:	37f83c60 	tbnz	w0, #31, 1b98 <vsnprintf+0x7bc>
    1410:	aa0203f8 	mov	x24, x2

	str = buf;
	end = buf + size;

	/* Make sure end is always >= buf */
	if (end < buf) {
    1414:	ab01037c 	adds	x28, x27, x1
    1418:	54000083 	b.cc	1428 <vsnprintf+0x4c>  // b.lo, b.ul, b.last
		end = ((void *)-1);
		size = end - buf;
    141c:	aa3b03e0 	mvn	x0, x27
		end = ((void *)-1);
    1420:	9280001c 	mov	x28, #0xffffffffffffffff    	// #-1
		size = end - buf;
    1424:	f90037e0 	str	x0, [sp, #104]
		end = ((void *)-1);
    1428:	aa1b03f4 	mov	x20, x27
    142c:	140000d1 	b	1770 <vsnprintf+0x394>
	}

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
    1430:	7100941f 	cmp	w0, #0x25
    1434:	540000c0 	b.eq	144c <vsnprintf+0x70>  // b.none
					*ip = (str - buf);
				}
				continue;

			case '%':
				if (str < end)
    1438:	eb1c029f 	cmp	x20, x28
    143c:	54000042 	b.cs	1444 <vsnprintf+0x68>  // b.hs, b.nlast
					*str = '%';
    1440:	39000280 	strb	w0, [x20]
				++str;
    1444:	91000694 	add	x20, x20, #0x1
				continue;
    1448:	140000c9 	b	176c <vsnprintf+0x390>
		flags = 0;
    144c:	52800017 	mov	w23, #0x0                   	// #0
    1450:	1400000e 	b	1488 <vsnprintf+0xac>
			switch (*fmt) {
    1454:	7100b41f 	cmp	w0, #0x2d
    1458:	54000140 	b.eq	1480 <vsnprintf+0xa4>  // b.none
    145c:	7100c01f 	cmp	w0, #0x30
    1460:	540004a0 	b.eq	14f4 <vsnprintf+0x118>  // b.none
		if (is_digit(*fmt))
    1464:	5100c001 	sub	w1, w0, #0x30
    1468:	12001c21 	and	w1, w1, #0xff
    146c:	7100243f 	cmp	w1, #0x9
    1470:	540001e8 	b.hi	14ac <vsnprintf+0xd0>  // b.pmore
	int i=0;
    1474:	52800016 	mov	w22, #0x0                   	// #0
		i = i*10 + *((*s)++) - '0';
    1478:	52800143 	mov	w3, #0xa                   	// #10
    147c:	14000023 	b	1508 <vsnprintf+0x12c>
				case '-': flags |= LEFT; goto repeat;
    1480:	321c02f7 	orr	w23, w23, #0x10
{
    1484:	aa0203f8 	mov	x24, x2
			switch (*fmt) {
    1488:	39400700 	ldrb	w0, [x24, #1]
			++fmt;		/* this also skips first '%' */
    148c:	91000702 	add	x2, x24, #0x1
			switch (*fmt) {
    1490:	7100ac1f 	cmp	w0, #0x2b
    1494:	54000240 	b.eq	14dc <vsnprintf+0x100>  // b.none
    1498:	54fffde8 	b.hi	1454 <vsnprintf+0x78>  // b.pmore
    149c:	7100801f 	cmp	w0, #0x20
    14a0:	54000220 	b.eq	14e4 <vsnprintf+0x108>  // b.none
    14a4:	71008c1f 	cmp	w0, #0x23
    14a8:	54000220 	b.eq	14ec <vsnprintf+0x110>  // b.none
		else if (*fmt == '*') {
    14ac:	7100a81f 	cmp	w0, #0x2a
    14b0:	54000641 	b.ne	1578 <vsnprintf+0x19c>  // b.any
			++fmt;
    14b4:	91000b02 	add	x2, x24, #0x2
			field_width = va_arg(args, int);
    14b8:	37f804b3 	tbnz	w19, #31, 154c <vsnprintf+0x170>
    14bc:	91002ce1 	add	x1, x7, #0xb
    14c0:	aa0703e0 	mov	x0, x7
    14c4:	927df027 	and	x7, x1, #0xfffffffffffffff8
    14c8:	b9400016 	ldr	w22, [x0]
			if (field_width < 0) {
    14cc:	36f80296 	tbz	w22, #31, 151c <vsnprintf+0x140>
				field_width = -field_width;
    14d0:	4b1603f6 	neg	w22, w22
				flags |= LEFT;
    14d4:	321c02f7 	orr	w23, w23, #0x10
    14d8:	14000011 	b	151c <vsnprintf+0x140>
				case '+': flags |= PLUS; goto repeat;
    14dc:	321e02f7 	orr	w23, w23, #0x4
    14e0:	17ffffe9 	b	1484 <vsnprintf+0xa8>
				case ' ': flags |= SPACE; goto repeat;
    14e4:	321d02f7 	orr	w23, w23, #0x8
    14e8:	17ffffe7 	b	1484 <vsnprintf+0xa8>
				case '#': flags |= SPECIAL; goto repeat;
    14ec:	321a02f7 	orr	w23, w23, #0x40
    14f0:	17ffffe5 	b	1484 <vsnprintf+0xa8>
				case '0': flags |= ZEROPAD; goto repeat;
    14f4:	320002f7 	orr	w23, w23, #0x1
    14f8:	17ffffe3 	b	1484 <vsnprintf+0xa8>
		i = i*10 + *((*s)++) - '0';
    14fc:	1b0302c0 	madd	w0, w22, w3, w0
    1500:	91000442 	add	x2, x2, #0x1
    1504:	5100c016 	sub	w22, w0, #0x30
	while (is_digit(**s))
    1508:	39400040 	ldrb	w0, [x2]
    150c:	5100c001 	sub	w1, w0, #0x30
    1510:	12001c21 	and	w1, w1, #0xff
    1514:	7100243f 	cmp	w1, #0x9
    1518:	54ffff29 	b.ls	14fc <vsnprintf+0x120>  // b.plast
		if (*fmt == '.') {
    151c:	39400040 	ldrb	w0, [x2]
    1520:	7100b81f 	cmp	w0, #0x2e
    1524:	54000ae1 	b.ne	1680 <vsnprintf+0x2a4>  // b.any
			if (is_digit(*fmt))
    1528:	39400443 	ldrb	w3, [x2, #1]
			++fmt;
    152c:	91000441 	add	x1, x2, #0x1
			if (is_digit(*fmt))
    1530:	5100c060 	sub	w0, w3, #0x30
    1534:	12001c00 	and	w0, w0, #0xff
    1538:	7100241f 	cmp	w0, #0x9
    153c:	540007a8 	b.hi	1630 <vsnprintf+0x254>  // b.pmore
	int i=0;
    1540:	52800005 	mov	w5, #0x0                   	// #0
		i = i*10 + *((*s)++) - '0';
    1544:	52800143 	mov	w3, #0xa                   	// #10
    1548:	14000011 	b	158c <vsnprintf+0x1b0>
			field_width = va_arg(args, int);
    154c:	11002261 	add	w1, w19, #0x8
    1550:	7100003f 	cmp	w1, #0x0
    1554:	540000cd 	b.le	156c <vsnprintf+0x190>
    1558:	91002ce3 	add	x3, x7, #0xb
    155c:	aa0703e0 	mov	x0, x7
    1560:	2a0103f3 	mov	w19, w1
    1564:	927df067 	and	x7, x3, #0xfffffffffffffff8
    1568:	17ffffd8 	b	14c8 <vsnprintf+0xec>
    156c:	8b33c340 	add	x0, x26, w19, sxtw
    1570:	2a0103f3 	mov	w19, w1
    1574:	17ffffd5 	b	14c8 <vsnprintf+0xec>
		field_width = -1;
    1578:	12800016 	mov	w22, #0xffffffff            	// #-1
    157c:	17ffffe8 	b	151c <vsnprintf+0x140>
		i = i*10 + *((*s)++) - '0';
    1580:	1b0308a5 	madd	w5, w5, w3, w2
    1584:	91000421 	add	x1, x1, #0x1
    1588:	5100c0a5 	sub	w5, w5, #0x30
	while (is_digit(**s))
    158c:	39400022 	ldrb	w2, [x1]
    1590:	5100c040 	sub	w0, w2, #0x30
    1594:	12001c00 	and	w0, w0, #0xff
    1598:	7100241f 	cmp	w0, #0x9
    159c:	54ffff29 	b.ls	1580 <vsnprintf+0x1a4>  // b.plast
			if (precision < 0)
    15a0:	710000bf 	cmp	w5, #0x0
    15a4:	aa0103e2 	mov	x2, x1
    15a8:	1a9fa0a5 	csel	w5, w5, wzr, ge	// ge = tcont
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
    15ac:	39400044 	ldrb	w4, [x2]
    15b0:	51013080 	sub	w0, w4, #0x4c
    15b4:	12001c00 	and	w0, w0, #0xff
    15b8:	7100b81f 	cmp	w0, #0x2e
    15bc:	540006c8 	b.hi	1694 <vsnprintf+0x2b8>  // b.pmore
    15c0:	d2880021 	mov	x1, #0x4001                	// #16385
    15c4:	f2a20001 	movk	x1, #0x1000, lsl #16
    15c8:	f2c82021 	movk	x1, #0x4101, lsl #32
    15cc:	9ac02420 	lsr	x0, x1, x0
    15d0:	36000620 	tbz	w0, #0, 1694 <vsnprintf+0x2b8>
			++fmt;
    15d4:	91000458 	add	x24, x2, #0x1
			if (qualifier == 'l' && *fmt == 'l') {
    15d8:	7101b09f 	cmp	w4, #0x6c
    15dc:	540000c1 	b.ne	15f4 <vsnprintf+0x218>  // b.any
    15e0:	39400440 	ldrb	w0, [x2, #1]
    15e4:	7101b01f 	cmp	w0, #0x6c
    15e8:	54000061 	b.ne	15f4 <vsnprintf+0x218>  // b.any
				++fmt;
    15ec:	91000858 	add	x24, x2, #0x2
				qualifier = 'L';
    15f0:	52800984 	mov	w4, #0x4c                  	// #76
		switch (*fmt) {
    15f4:	39400300 	ldrb	w0, [x24]
    15f8:	7100941f 	cmp	w0, #0x25
    15fc:	54fff1e0 	b.eq	1438 <vsnprintf+0x5c>  // b.none
    1600:	51016000 	sub	w0, w0, #0x58
    1604:	12001c01 	and	w1, w0, #0xff
    1608:	7100803f 	cmp	w1, #0x20
    160c:	54002368 	b.hi	1a78 <vsnprintf+0x69c>  // b.pmore
    1610:	7100801f 	cmp	w0, #0x20
    1614:	54002328 	b.hi	1a78 <vsnprintf+0x69c>  // b.pmore
    1618:	d0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    161c:	912cc021 	add	x1, x1, #0xb30
    1620:	78605821 	ldrh	w1, [x1, w0, uxtw #1]
    1624:	10000060 	adr	x0, 1630 <vsnprintf+0x254>
    1628:	8b21a801 	add	x1, x0, w1, sxth #2
    162c:	d61f0020 	br	x1
			else if (*fmt == '*') {
    1630:	7100a87f 	cmp	w3, #0x2a
    1634:	540002a1 	b.ne	1688 <vsnprintf+0x2ac>  // b.any
				++fmt;
    1638:	91000841 	add	x1, x2, #0x2
				precision = va_arg(args, int);
    163c:	37f80113 	tbnz	w19, #31, 165c <vsnprintf+0x280>
    1640:	91002ce0 	add	x0, x7, #0xb
    1644:	2a1303e2 	mov	w2, w19
    1648:	927df000 	and	x0, x0, #0xfffffffffffffff8
    164c:	b94000e5 	ldr	w5, [x7]
    1650:	2a0203f3 	mov	w19, w2
    1654:	aa0003e7 	mov	x7, x0
    1658:	17ffffd2 	b	15a0 <vsnprintf+0x1c4>
    165c:	11002262 	add	w2, w19, #0x8
    1660:	7100005f 	cmp	w2, #0x0
    1664:	5400008d 	b.le	1674 <vsnprintf+0x298>
    1668:	91002ce0 	add	x0, x7, #0xb
    166c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    1670:	17fffff7 	b	164c <vsnprintf+0x270>
    1674:	aa0703e0 	mov	x0, x7
    1678:	8b33c347 	add	x7, x26, w19, sxtw
    167c:	17fffff4 	b	164c <vsnprintf+0x270>
		precision = -1;
    1680:	12800005 	mov	w5, #0xffffffff            	// #-1
    1684:	17ffffca 	b	15ac <vsnprintf+0x1d0>
			++fmt;
    1688:	aa0103e2 	mov	x2, x1
				precision = 0;
    168c:	52800005 	mov	w5, #0x0                   	// #0
    1690:	17ffffc7 	b	15ac <vsnprintf+0x1d0>
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
    1694:	aa0203f8 	mov	x24, x2
    1698:	12800004 	mov	w4, #0xffffffff            	// #-1
    169c:	17ffffd6 	b	15f4 <vsnprintf+0x218>

				/* integer number formats - set up the flags and "break" */
			case 'o':
				base = 8;
    16a0:	52800103 	mov	w3, #0x8                   	// #8
				} else {
					--fmt;
				}
				continue;
		}
		if (qualifier == 'L')
    16a4:	7101309f 	cmp	w4, #0x4c
    16a8:	54002061 	b.ne	1ab4 <vsnprintf+0x6d8>  // b.any
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
    16ac:	37f822d3 	tbnz	w19, #31, 1b04 <vsnprintf+0x728>
    16b0:	91003cf5 	add	x21, x7, #0xf
    16b4:	2a1303f9 	mov	w25, w19
    16b8:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    16bc:	f94000e2 	ldr	x2, [x7]
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
				num = (signed int) num;
		}
		str = number(str, end, num, base,
    16c0:	aa1403e0 	mov	x0, x20
    16c4:	2a1703e6 	mov	w6, w23
    16c8:	2a1603e4 	mov	w4, w22
    16cc:	aa1c03e1 	mov	x1, x28
    16d0:	97fffe87 	bl	10ec <number>
    16d4:	aa0003f4 	mov	x20, x0
    16d8:	14000062 	b	1860 <vsnprintf+0x484>
				if (!(flags & LEFT)) {
    16dc:	37200217 	tbnz	w23, #4, 171c <vsnprintf+0x340>
    16e0:	2a1603e1 	mov	w1, w22
    16e4:	aa1403e0 	mov	x0, x20
							*str = ' ';
    16e8:	52800402 	mov	w2, #0x20                  	// #32
    16ec:	14000005 	b	1700 <vsnprintf+0x324>
						if (str < end)
    16f0:	eb1c001f 	cmp	x0, x28
    16f4:	54000042 	b.cs	16fc <vsnprintf+0x320>  // b.hs, b.nlast
							*str = ' ';
    16f8:	39000002 	strb	w2, [x0]
						++str;
    16fc:	91000400 	add	x0, x0, #0x1
					while (--field_width > 0) {
    1700:	51000421 	sub	w1, w1, #0x1
    1704:	7100003f 	cmp	w1, #0x0
    1708:	54ffff4c 	b.gt	16f0 <vsnprintf+0x314>
    170c:	710006d6 	subs	w22, w22, #0x1
    1710:	1a9f52c0 	csel	w0, w22, wzr, pl	// pl = nfrst
    1714:	4b0002d6 	sub	w22, w22, w0
    1718:	8b20c294 	add	x20, x20, w0, sxtw
				c = (unsigned char) va_arg(args, int);
    171c:	37f80493 	tbnz	w19, #31, 17ac <vsnprintf+0x3d0>
    1720:	91002ce1 	add	x1, x7, #0xb
    1724:	2a1303e3 	mov	w3, w19
    1728:	927df021 	and	x1, x1, #0xfffffffffffffff8
				if (str < end)
    172c:	eb1c029f 	cmp	x20, x28
    1730:	54000062 	b.cs	173c <vsnprintf+0x360>  // b.hs, b.nlast
				c = (unsigned char) va_arg(args, int);
    1734:	b94000e0 	ldr	w0, [x7]
    1738:	39000280 	strb	w0, [x20]
				++str;
    173c:	91000694 	add	x20, x20, #0x1
				while (--field_width > 0) {
    1740:	2a1603e4 	mov	w4, w22
				++str;
    1744:	aa1403e2 	mov	x2, x20
						*str = ' ';
    1748:	52800400 	mov	w0, #0x20                  	// #32
				while (--field_width > 0) {
    174c:	51000484 	sub	w4, w4, #0x1
    1750:	7100009f 	cmp	w4, #0x0
    1754:	540003ec 	b.gt	17d0 <vsnprintf+0x3f4>
    1758:	710006d6 	subs	w22, w22, #0x1
    175c:	2a0303f3 	mov	w19, w3
    1760:	1a9f52d6 	csel	w22, w22, wzr, pl	// pl = nfrst
    1764:	aa0103e7 	mov	x7, x1
    1768:	8b36c294 	add	x20, x20, w22, sxtw
	for (; *fmt ; ++fmt) {
    176c:	91000718 	add	x24, x24, #0x1
    1770:	39400300 	ldrb	w0, [x24]
    1774:	35ffe5e0 	cbnz	w0, 1430 <vsnprintf+0x54>
				field_width, precision, flags);
	}
	if (size > 0) {
    1778:	f94037e0 	ldr	x0, [sp, #104]
    177c:	b4000080 	cbz	x0, 178c <vsnprintf+0x3b0>
		if (str < end)
    1780:	eb1c029f 	cmp	x20, x28
    1784:	54002062 	b.cs	1b90 <vsnprintf+0x7b4>  // b.hs, b.nlast
			*str = '\0';
    1788:	3900029f 	strb	wzr, [x20]
		else
			end[-1] = '\0';
	}
	/* the trailing null byte doesn't count towards the total */
	return str-buf;
    178c:	4b1b0280 	sub	w0, w20, w27
}
    1790:	a94153f3 	ldp	x19, x20, [sp, #16]
    1794:	a9425bf5 	ldp	x21, x22, [sp, #32]
    1798:	a94363f7 	ldp	x23, x24, [sp, #48]
    179c:	a9446bf9 	ldp	x25, x26, [sp, #64]
    17a0:	a94573fb 	ldp	x27, x28, [sp, #80]
    17a4:	a8c77bfd 	ldp	x29, x30, [sp], #112
    17a8:	d65f03c0 	ret
				c = (unsigned char) va_arg(args, int);
    17ac:	11002263 	add	w3, w19, #0x8
    17b0:	7100007f 	cmp	w3, #0x0
    17b4:	5400008d 	b.le	17c4 <vsnprintf+0x3e8>
    17b8:	91002ce1 	add	x1, x7, #0xb
    17bc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    17c0:	17ffffdb 	b	172c <vsnprintf+0x350>
    17c4:	aa0703e1 	mov	x1, x7
    17c8:	8b33c347 	add	x7, x26, w19, sxtw
    17cc:	17ffffd8 	b	172c <vsnprintf+0x350>
					if (str < end)
    17d0:	eb1c005f 	cmp	x2, x28
    17d4:	54000042 	b.cs	17dc <vsnprintf+0x400>  // b.hs, b.nlast
						*str = ' ';
    17d8:	39000040 	strb	w0, [x2]
					++str;
    17dc:	91000442 	add	x2, x2, #0x1
    17e0:	17ffffdb 	b	174c <vsnprintf+0x370>
					str = string(str, end, va_arg(args, char *),
    17e4:	37f80433 	tbnz	w19, #31, 1868 <vsnprintf+0x48c>
    17e8:	91003cf5 	add	x21, x7, #0xf
    17ec:	2a1303f9 	mov	w25, w19
    17f0:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    17f4:	f94000f3 	ldr	x19, [x7]
	if ((unsigned long)s < PAGE_SIZE)
    17f8:	f13ffe7f 	cmp	x19, #0xfff
    17fc:	54000068 	b.hi	1808 <vsnprintf+0x42c>  // b.pmore
		s = "<NULL>";
    1800:	d0000013 	adrp	x19, 3000 <lz4_decompress+0x324>
    1804:	9124d273 	add	x19, x19, #0x934
	len = strnlen(s, precision);
    1808:	93407ca1 	sxtw	x1, w5
    180c:	aa1303e0 	mov	x0, x19
    1810:	94000824 	bl	38a0 <strnlen>
    1814:	2a0003e3 	mov	w3, w0
	if (!(flags & LEFT)) {
    1818:	362005f7 	tbz	w23, #4, 18d4 <vsnprintf+0x4f8>
	for (i = 0; i < len; ++i) {
    181c:	d2800001 	mov	x1, #0x0                   	// #0
    1820:	6b01007f 	cmp	w3, w1
    1824:	5400060c 	b.gt	18e4 <vsnprintf+0x508>
    1828:	92407c01 	and	x1, x0, #0xffffffff
    182c:	7100001f 	cmp	w0, #0x0
    1830:	9a9fa021 	csel	x1, x1, xzr, ge	// ge = tcont
			*buf = ' ';
    1834:	52800406 	mov	w6, #0x20                  	// #32
    1838:	8b010281 	add	x1, x20, x1
	for (i = 0; i < len; ++i) {
    183c:	aa0103e2 	mov	x2, x1
	while (len < (*field_width)--) {
    1840:	0b0102c5 	add	w5, w22, w1
    1844:	4b0200a4 	sub	w4, w5, w2
    1848:	6b04007f 	cmp	w3, w4
    184c:	540005ab 	b.lt	1900 <vsnprintf+0x524>  // b.tstop
    1850:	4b0002d4 	sub	w20, w22, w0
    1854:	6b16001f 	cmp	w0, w22
    1858:	9a9fd294 	csel	x20, x20, xzr, le
    185c:	8b140034 	add	x20, x1, x20
		str = number(str, end, num, base,
    1860:	2a1903f3 	mov	w19, w25
    1864:	14000043 	b	1970 <vsnprintf+0x594>
					str = string(str, end, va_arg(args, char *),
    1868:	11002279 	add	w25, w19, #0x8
    186c:	7100033f 	cmp	w25, #0x0
    1870:	5400008d 	b.le	1880 <vsnprintf+0x4a4>
    1874:	91003cf5 	add	x21, x7, #0xf
    1878:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    187c:	17ffffde 	b	17f4 <vsnprintf+0x418>
    1880:	aa0703f5 	mov	x21, x7
    1884:	8b33c347 	add	x7, x26, w19, sxtw
    1888:	17ffffdb 	b	17f4 <vsnprintf+0x418>
			if (buf < end)
    188c:	eb01039f 	cmp	x28, x1
    1890:	54000049 	b.ls	1898 <vsnprintf+0x4bc>  // b.plast
				*buf = ' ';
    1894:	39000025 	strb	w5, [x1]
			++buf;
    1898:	91000421 	add	x1, x1, #0x1
		while (len < (*field_width)--) {
    189c:	4b010082 	sub	w2, w4, w1
    18a0:	6b02007f 	cmp	w3, w2
    18a4:	54ffff4b 	b.lt	188c <vsnprintf+0x4b0>  // b.tstop
    18a8:	6b0002df 	cmp	w22, w0
    18ac:	4b0002c1 	sub	w1, w22, w0
    18b0:	1a9fb7e2 	cset	w2, ge	// ge = tcont
    18b4:	7100005f 	cmp	w2, #0x0
    18b8:	9a9f1021 	csel	x1, x1, xzr, ne	// ne = any
    18bc:	8b010294 	add	x20, x20, x1
    18c0:	4b160001 	sub	w1, w0, w22
    18c4:	1a9f1021 	csel	w1, w1, wzr, ne	// ne = any
    18c8:	510006d6 	sub	w22, w22, #0x1
    18cc:	0b160036 	add	w22, w1, w22
    18d0:	17ffffd3 	b	181c <vsnprintf+0x440>
    18d4:	aa1403e1 	mov	x1, x20
    18d8:	0b1402c4 	add	w4, w22, w20
				*buf = ' ';
    18dc:	52800405 	mov	w5, #0x20                  	// #32
    18e0:	17ffffef 	b	189c <vsnprintf+0x4c0>
		if (buf < end)
    18e4:	8b010282 	add	x2, x20, x1
    18e8:	eb02039f 	cmp	x28, x2
    18ec:	54000069 	b.ls	18f8 <vsnprintf+0x51c>  // b.plast
			*buf = *s;
    18f0:	38616a62 	ldrb	w2, [x19, x1]
    18f4:	38216a82 	strb	w2, [x20, x1]
	for (i = 0; i < len; ++i) {
    18f8:	91000421 	add	x1, x1, #0x1
    18fc:	17ffffc9 	b	1820 <vsnprintf+0x444>
		if (buf < end)
    1900:	eb02039f 	cmp	x28, x2
    1904:	54000049 	b.ls	190c <vsnprintf+0x530>  // b.plast
			*buf = ' ';
    1908:	39000046 	strb	w6, [x2]
		++buf;
    190c:	91000442 	add	x2, x2, #0x1
    1910:	17ffffcd 	b	1844 <vsnprintf+0x468>
						va_arg(args, void *),
    1914:	37f80333 	tbnz	w19, #31, 1978 <vsnprintf+0x59c>
    1918:	91003cf5 	add	x21, x7, #0xf
    191c:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1920:	f94000e2 	ldr	x2, [x7]
	if (field_width == -1) {
    1924:	310006df 	cmn	w22, #0x1
    1928:	54000400 	b.eq	19a8 <vsnprintf+0x5cc>  // b.none
	flags |= SMALL;
    192c:	321b02e6 	orr	w6, w23, #0x20
	return number(buf, end, (unsigned long) ptr, 16, field_width, precision, flags);
    1930:	aa1403e0 	mov	x0, x20
    1934:	2a1603e4 	mov	w4, w22
    1938:	aa1c03e1 	mov	x1, x28
    193c:	52800203 	mov	w3, #0x10                  	// #16
    1940:	97fffdeb 	bl	10ec <number>
    1944:	aa0003f4 	mov	x20, x0
				while (is_alnum(fmt[1]))
    1948:	39400700 	ldrb	w0, [x24, #1]
    194c:	5100c001 	sub	w1, w0, #0x30
    1950:	12001c21 	and	w1, w1, #0xff
    1954:	7100243f 	cmp	w1, #0x9
    1958:	54000309 	b.ls	19b8 <vsnprintf+0x5dc>  // b.plast
    195c:	121a7800 	and	w0, w0, #0xffffffdf
    1960:	51010400 	sub	w0, w0, #0x41
    1964:	12001c00 	and	w0, w0, #0xff
    1968:	7100641f 	cmp	w0, #0x19
    196c:	54000269 	b.ls	19b8 <vsnprintf+0x5dc>  // b.plast
		str = number(str, end, num, base,
    1970:	aa1503e7 	mov	x7, x21
    1974:	17ffff7e 	b	176c <vsnprintf+0x390>
						va_arg(args, void *),
    1978:	11002260 	add	w0, w19, #0x8
    197c:	7100001f 	cmp	w0, #0x0
    1980:	540000ad 	b.le	1994 <vsnprintf+0x5b8>
    1984:	91003cf5 	add	x21, x7, #0xf
    1988:	2a0003f3 	mov	w19, w0
    198c:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1990:	17ffffe4 	b	1920 <vsnprintf+0x544>
    1994:	8b33c341 	add	x1, x26, w19, sxtw
    1998:	aa0703f5 	mov	x21, x7
    199c:	2a0003f3 	mov	w19, w0
    19a0:	aa0103e7 	mov	x7, x1
    19a4:	17ffffdf 	b	1920 <vsnprintf+0x544>
		flags |= ZEROPAD;
    19a8:	52800426 	mov	w6, #0x21                  	// #33
		field_width = 2*sizeof(void *);
    19ac:	52800216 	mov	w22, #0x10                  	// #16
		flags |= ZEROPAD;
    19b0:	2a0602e6 	orr	w6, w23, w6
    19b4:	17ffffdf 	b	1930 <vsnprintf+0x554>
					fmt++;
    19b8:	91000718 	add	x24, x24, #0x1
    19bc:	17ffffe3 	b	1948 <vsnprintf+0x56c>
				if (qualifier == 'l') {
    19c0:	7101b09f 	cmp	w4, #0x6c
    19c4:	cb1b0282 	sub	x2, x20, x27
    19c8:	54000141 	b.ne	19f0 <vsnprintf+0x614>  // b.any
					size_t * ip = va_arg(args, size_t *);
    19cc:	37f80273 	tbnz	w19, #31, 1a18 <vsnprintf+0x63c>
    19d0:	91003ce0 	add	x0, x7, #0xf
    19d4:	2a1303e1 	mov	w1, w19
    19d8:	927df000 	and	x0, x0, #0xfffffffffffffff8
    19dc:	f94000e3 	ldr	x3, [x7]
					*ip = (str - buf);
    19e0:	f9000062 	str	x2, [x3]
					*ip = (str - buf);
    19e4:	2a0103f3 	mov	w19, w1
    19e8:	aa0003e7 	mov	x7, x0
    19ec:	17ffff60 	b	176c <vsnprintf+0x390>
				} else if (qualifier == 'Z' || qualifier == 'z') {
    19f0:	121a7884 	and	w4, w4, #0xffffffdf
    19f4:	7101689f 	cmp	w4, #0x5a
    19f8:	54fffea0 	b.eq	19cc <vsnprintf+0x5f0>  // b.none
					int * ip = va_arg(args, int *);
    19fc:	37f80213 	tbnz	w19, #31, 1a3c <vsnprintf+0x660>
    1a00:	91003ce0 	add	x0, x7, #0xf
    1a04:	2a1303e1 	mov	w1, w19
    1a08:	927df000 	and	x0, x0, #0xfffffffffffffff8
    1a0c:	f94000e3 	ldr	x3, [x7]
					*ip = (str - buf);
    1a10:	b9000062 	str	w2, [x3]
    1a14:	17fffff4 	b	19e4 <vsnprintf+0x608>
					size_t * ip = va_arg(args, size_t *);
    1a18:	11002261 	add	w1, w19, #0x8
    1a1c:	7100003f 	cmp	w1, #0x0
    1a20:	5400008d 	b.le	1a30 <vsnprintf+0x654>
    1a24:	91003ce0 	add	x0, x7, #0xf
    1a28:	927df000 	and	x0, x0, #0xfffffffffffffff8
    1a2c:	17ffffec 	b	19dc <vsnprintf+0x600>
    1a30:	aa0703e0 	mov	x0, x7
    1a34:	8b33c347 	add	x7, x26, w19, sxtw
    1a38:	17ffffe9 	b	19dc <vsnprintf+0x600>
					int * ip = va_arg(args, int *);
    1a3c:	11002261 	add	w1, w19, #0x8
    1a40:	7100003f 	cmp	w1, #0x0
    1a44:	5400008d 	b.le	1a54 <vsnprintf+0x678>
    1a48:	91003ce0 	add	x0, x7, #0xf
    1a4c:	927df000 	and	x0, x0, #0xfffffffffffffff8
    1a50:	17ffffef 	b	1a0c <vsnprintf+0x630>
    1a54:	aa0703e0 	mov	x0, x7
    1a58:	8b33c347 	add	x7, x26, w19, sxtw
    1a5c:	17ffffec 	b	1a0c <vsnprintf+0x630>
				flags |= SMALL;
    1a60:	321b02f7 	orr	w23, w23, #0x20
		switch (*fmt) {
    1a64:	52800203 	mov	w3, #0x10                  	// #16
    1a68:	17ffff0f 	b	16a4 <vsnprintf+0x2c8>
				flags |= SIGN;
    1a6c:	321f02f7 	orr	w23, w23, #0x2
		base = 10;
    1a70:	52800143 	mov	w3, #0xa                   	// #10
    1a74:	17ffff0c 	b	16a4 <vsnprintf+0x2c8>
				if (str < end)
    1a78:	eb1c029f 	cmp	x20, x28
    1a7c:	54000062 	b.cs	1a88 <vsnprintf+0x6ac>  // b.hs, b.nlast
					*str = '%';
    1a80:	528004a0 	mov	w0, #0x25                  	// #37
    1a84:	39000280 	strb	w0, [x20]
				if (*fmt) {
    1a88:	39400301 	ldrb	w1, [x24]
				++str;
    1a8c:	91000680 	add	x0, x20, #0x1
				if (*fmt) {
    1a90:	340000c1 	cbz	w1, 1aa8 <vsnprintf+0x6cc>
					if (str < end)
    1a94:	eb1c001f 	cmp	x0, x28
    1a98:	54000042 	b.cs	1aa0 <vsnprintf+0x6c4>  // b.hs, b.nlast
						*str = *fmt;
    1a9c:	39000681 	strb	w1, [x20, #1]
					++str;
    1aa0:	91000a94 	add	x20, x20, #0x2
    1aa4:	17ffff32 	b	176c <vsnprintf+0x390>
					--fmt;
    1aa8:	d1000718 	sub	x24, x24, #0x1
				++str;
    1aac:	aa0003f4 	mov	x20, x0
    1ab0:	17ffff2f 	b	176c <vsnprintf+0x390>
		else if (qualifier == 'l') {
    1ab4:	7101b09f 	cmp	w4, #0x6c
    1ab8:	54ffdfa0 	b.eq	16ac <vsnprintf+0x2d0>  // b.none
		} else if (qualifier == 'Z' || qualifier == 'z') {
    1abc:	121a7880 	and	w0, w4, #0xffffffdf
    1ac0:	7101681f 	cmp	w0, #0x5a
    1ac4:	54ffdf40 	b.eq	16ac <vsnprintf+0x2d0>  // b.none
		} else if (qualifier == 't') {
    1ac8:	7101d09f 	cmp	w4, #0x74
    1acc:	54ffdf00 	b.eq	16ac <vsnprintf+0x2d0>  // b.none
		} else if (qualifier == 'h') {
    1ad0:	7101a09f 	cmp	w4, #0x68
    1ad4:	121f02e0 	and	w0, w23, #0x2
    1ad8:	540003a1 	b.ne	1b4c <vsnprintf+0x770>  // b.any
			num = (unsigned short) va_arg(args, int);
    1adc:	37f80273 	tbnz	w19, #31, 1b28 <vsnprintf+0x74c>
    1ae0:	91002cf5 	add	x21, x7, #0xb
    1ae4:	2a1303f9 	mov	w25, w19
    1ae8:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1aec:	b94000e2 	ldr	w2, [x7]
    1af0:	92403c41 	and	x1, x2, #0xffff
    1af4:	93403c42 	sxth	x2, w2
			num = va_arg(args, unsigned int);
    1af8:	7100001f 	cmp	w0, #0x0
    1afc:	9a811042 	csel	x2, x2, x1, ne	// ne = any
    1b00:	17fffef0 	b	16c0 <vsnprintf+0x2e4>
			num = va_arg(args, ptrdiff_t);
    1b04:	11002279 	add	w25, w19, #0x8
    1b08:	7100033f 	cmp	w25, #0x0
    1b0c:	5400008d 	b.le	1b1c <vsnprintf+0x740>
    1b10:	91003cf5 	add	x21, x7, #0xf
    1b14:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1b18:	17fffee9 	b	16bc <vsnprintf+0x2e0>
    1b1c:	aa0703f5 	mov	x21, x7
    1b20:	8b33c347 	add	x7, x26, w19, sxtw
    1b24:	17fffee6 	b	16bc <vsnprintf+0x2e0>
			num = (unsigned short) va_arg(args, int);
    1b28:	11002279 	add	w25, w19, #0x8
    1b2c:	7100033f 	cmp	w25, #0x0
    1b30:	5400008d 	b.le	1b40 <vsnprintf+0x764>
    1b34:	91002cf5 	add	x21, x7, #0xb
    1b38:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1b3c:	17ffffec 	b	1aec <vsnprintf+0x710>
    1b40:	aa0703f5 	mov	x21, x7
    1b44:	8b33c347 	add	x7, x26, w19, sxtw
    1b48:	17ffffe9 	b	1aec <vsnprintf+0x710>
			num = va_arg(args, unsigned int);
    1b4c:	37f80113 	tbnz	w19, #31, 1b6c <vsnprintf+0x790>
    1b50:	91002cf5 	add	x21, x7, #0xb
    1b54:	2a1303f9 	mov	w25, w19
    1b58:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1b5c:	b94000e2 	ldr	w2, [x7]
    1b60:	2a0203e1 	mov	w1, w2
    1b64:	93407c42 	sxtw	x2, w2
    1b68:	17ffffe4 	b	1af8 <vsnprintf+0x71c>
    1b6c:	11002279 	add	w25, w19, #0x8
    1b70:	7100033f 	cmp	w25, #0x0
    1b74:	5400008d 	b.le	1b84 <vsnprintf+0x7a8>
    1b78:	91002cf5 	add	x21, x7, #0xb
    1b7c:	927df2b5 	and	x21, x21, #0xfffffffffffffff8
    1b80:	17fffff7 	b	1b5c <vsnprintf+0x780>
    1b84:	aa0703f5 	mov	x21, x7
    1b88:	8b33c347 	add	x7, x26, w19, sxtw
    1b8c:	17fffff4 	b	1b5c <vsnprintf+0x780>
			end[-1] = '\0';
    1b90:	381ff39f 	sturb	wzr, [x28, #-1]
    1b94:	17fffefe 	b	178c <vsnprintf+0x3b0>
		return 0;
    1b98:	52800000 	mov	w0, #0x0                   	// #0
    1b9c:	17fffefd 	b	1790 <vsnprintf+0x3b4>

0000000000001ba0 <dt_2nd_aarch64>:

/* called from assembly */
void dt_2nd_aarch64(void *fdt);

void dt_2nd_aarch64(void *fdt)
{
    1ba0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    1ba4:	910003fd 	mov	x29, sp
    1ba8:	f9000bf3 	str	x19, [sp, #16]
    1bac:	aa0003f3 	mov	x19, x0
}

static __always_inline u32 ___raw_readl(const volatile void __iomem *addr)
{
	u32 val;
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1bb0:	d2860180 	mov	x0, #0x300c                	// #12300
	unsigned long membase, memsize;
    1bb4:	a9027fff 	stp	xzr, xzr, [sp, #32]
    1bb8:	f2bff000 	movk	x0, #0xff80, lsl #16
    1bbc:	b9400001 	ldr	w1, [x0]
static inline void meson_serial_putc(void *ctx, int c)
{
	void __iomem *base = IOMEM(ctx);

	/* Wait until TX FIFO is not full */
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1bc0:	37afffe1 	tbnz	w1, #21, 1bbc <dt_2nd_aarch64+0x1c>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1bc4:	d2860002 	mov	x2, #0x3000                	// #12288
    1bc8:	528007c1 	mov	w1, #0x3e                  	// #62
    1bcc:	f2bff002 	movk	x2, #0xff80, lsl #16
    1bd0:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1bd4:	b9400001 	ldr	w1, [x0]

	/* Write character to TX FIFO */
	writel(c, base + AML_UART_WFIFO);

	/* Wait until character is transmitted (TX FIFO empty) */
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1bd8:	36b7ffe1 	tbz	w1, #22, 1bd4 <dt_2nd_aarch64+0x34>
    1bdc:	d2860180 	mov	x0, #0x300c                	// #12300
    1be0:	f2bff000 	movk	x0, #0xff80, lsl #16
    1be4:	b9400001 	ldr	w1, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1be8:	37afffe1 	tbnz	w1, #21, 1be4 <dt_2nd_aarch64+0x44>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1bec:	d2860002 	mov	x2, #0x3000                	// #12288
    1bf0:	528007c1 	mov	w1, #0x3e                  	// #62
    1bf4:	f2bff002 	movk	x2, #0xff80, lsl #16
    1bf8:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1bfc:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1c00:	36b7ffe1 	tbz	w1, #22, 1bfc <dt_2nd_aarch64+0x5c>
    1c04:	d2860180 	mov	x0, #0x300c                	// #12300
    1c08:	f2bff000 	movk	x0, #0xff80, lsl #16
    1c0c:	b9400001 	ldr	w1, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1c10:	37afffe1 	tbnz	w1, #21, 1c0c <dt_2nd_aarch64+0x6c>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1c14:	d2860002 	mov	x2, #0x3000                	// #12288
    1c18:	528007c1 	mov	w1, #0x3e                  	// #62
    1c1c:	f2bff002 	movk	x2, #0xff80, lsl #16
    1c20:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1c24:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1c28:	36b7ffe1 	tbz	w1, #22, 1c24 <dt_2nd_aarch64+0x84>
	putc_ll('>');
	putc_ll('>');

	/* entry point already set up stack */

	arm_cpu_lowlevel_init();
    1c2c:	97fff90b 	bl	58 <arm_cpu_lowlevel_init>

	relocate_to_current_adr();
    1c30:	94000075 	bl	1e04 <relocate_to_current_adr>
	setup_c();
    1c34:	940002e4 	bl	27c4 <setup_c>

	if (!fdt)
    1c38:	b5000053 	cbnz	x19, 1c40 <dt_2nd_aarch64+0xa0>
		hang();
    1c3c:	940006a5 	bl	36d0 <hang>

	fdt_find_mem(fdt, &membase, &memsize);
    1c40:	9100a3e2 	add	x2, sp, #0x28
    1c44:	910083e1 	add	x1, sp, #0x20
    1c48:	aa1303e0 	mov	x0, x19
    1c4c:	94000598 	bl	32ac <fdt_find_mem>

	// ?
	barebox_arm_entry(membase, memsize, fdt);
    1c50:	a94207e0 	ldp	x0, x1, [sp, #32]
    1c54:	aa1303e2 	mov	x2, x19
    1c58:	94000118 	bl	20b8 <barebox_arm_entry>

0000000000001c5c <v8_flush_dcache_level>:
    1c5c:	d37ff80c 	lsl	x12, x0, #1
    1c60:	d51a000c 	msr	csselr_el1, x12
    1c64:	d5033fdf 	isb
    1c68:	d5390006 	mrs	x6, ccsidr_el1
    1c6c:	924008c2 	and	x2, x6, #0x7
    1c70:	91001042 	add	x2, x2, #0x4
    1c74:	d2807fe3 	mov	x3, #0x3ff                 	// #1023
    1c78:	8a460c63 	and	x3, x3, x6, lsr #3
    1c7c:	5ac01065 	clz	w5, w3
    1c80:	d28fffe4 	mov	x4, #0x7fff                	// #32767
    1c84:	8a463484 	and	x4, x4, x6, lsr #13

0000000000001c88 <loop_set>:
    1c88:	aa0303e6 	mov	x6, x3

0000000000001c8c <loop_way>:
    1c8c:	9ac520c7 	lsl	x7, x6, x5
    1c90:	aa070189 	orr	x9, x12, x7
    1c94:	9ac22087 	lsl	x7, x4, x2
    1c98:	aa070129 	orr	x9, x9, x7
    1c9c:	36000061 	tbz	w1, #0, 1ca8 <loop_way+0x1c>
    1ca0:	d5087649 	dc	isw, x9
    1ca4:	14000002 	b	1cac <loop_way+0x20>
    1ca8:	d5087e49 	dc	cisw, x9
    1cac:	f10004c6 	subs	x6, x6, #0x1
    1cb0:	54fffeea 	b.ge	1c8c <loop_way>  // b.tcont
    1cb4:	f1000484 	subs	x4, x4, #0x1
    1cb8:	54fffe8a 	b.ge	1c88 <loop_set>  // b.tcont
    1cbc:	d65f03c0 	ret

0000000000001cc0 <v8_dcache_all>:
    1cc0:	aa0003e1 	mov	x1, x0
    1cc4:	d5033f9f 	dsb	sy
    1cc8:	d539002a 	mrs	x10, clidr_el1
    1ccc:	d358fd4b 	lsr	x11, x10, #24
    1cd0:	9240096b 	and	x11, x11, #0x7
    1cd4:	b400024b 	cbz	x11, 1d1c <finished>
    1cd8:	aa1e03ef 	mov	x15, x30
    1cdc:	d2800000 	mov	x0, #0x0                   	// #0

0000000000001ce0 <loop_level>:
    1ce0:	d37ff80c 	lsl	x12, x0, #1
    1ce4:	8b00018c 	add	x12, x12, x0
    1ce8:	9acc254c 	lsr	x12, x10, x12
    1cec:	9240098c 	and	x12, x12, #0x7
    1cf0:	f100099f 	cmp	x12, #0x2
    1cf4:	5400004b 	b.lt	1cfc <skip>  // b.tstop
    1cf8:	97ffffd9 	bl	1c5c <v8_flush_dcache_level>

0000000000001cfc <skip>:
    1cfc:	91000400 	add	x0, x0, #0x1
    1d00:	eb00017f 	cmp	x11, x0
    1d04:	54fffeec 	b.gt	1ce0 <loop_level>
    1d08:	d2800000 	mov	x0, #0x0                   	// #0
    1d0c:	d51a0000 	msr	csselr_el1, x0
    1d10:	d5033f9f 	dsb	sy
    1d14:	d5033fdf 	isb
    1d18:	aa0f03fe 	mov	x30, x15

0000000000001d1c <finished>:
    1d1c:	d65f03c0 	ret

0000000000001d20 <v8_flush_dcache_all>:
    1d20:	aa1e03f0 	mov	x16, x30
    1d24:	d2800000 	mov	x0, #0x0                   	// #0
    1d28:	97ffffe6 	bl	1cc0 <v8_dcache_all>
    1d2c:	aa1003fe 	mov	x30, x16
    1d30:	d65f03c0 	ret

0000000000001d34 <v8_invalidate_dcache_all>:
    1d34:	aa1e03f0 	mov	x16, x30
    1d38:	d2800020 	mov	x0, #0x1                   	// #1
    1d3c:	97ffffe1 	bl	1cc0 <v8_dcache_all>
    1d40:	aa1003fe 	mov	x30, x16
    1d44:	d65f03c0 	ret

0000000000001d48 <v8_flush_dcache_range>:
    1d48:	d53b0023 	mrs	x3, ctr_el0
    1d4c:	d350fc63 	lsr	x3, x3, #16
    1d50:	92400c63 	and	x3, x3, #0xf
    1d54:	d2800082 	mov	x2, #0x4                   	// #4
    1d58:	9ac32042 	lsl	x2, x2, x3
    1d5c:	d1000443 	sub	x3, x2, #0x1
    1d60:	8a230000 	bic	x0, x0, x3
    1d64:	d50b7e20 	dc	civac, x0
    1d68:	8b020000 	add	x0, x0, x2
    1d6c:	eb01001f 	cmp	x0, x1
    1d70:	54ffffa3 	b.cc	1d64 <v8_flush_dcache_range+0x1c>  // b.lo, b.ul, b.last
    1d74:	d5033f9f 	dsb	sy
    1d78:	d65f03c0 	ret

0000000000001d7c <v8_invalidate_icache_all>:
    1d7c:	d508711f 	ic	ialluis
    1d80:	d5033fdf 	isb
    1d84:	d65f03c0 	ret

0000000000001d88 <arm_early_mmu_cache_flush>:
/*
 * Early function to flush the caches. This is for use when the
 * C environment is not yet fully initialized.
 */
void arm_early_mmu_cache_flush(void)
{
    1d88:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    1d8c:	910003fd 	mov	x29, sp
	v8_flush_dcache_all();
    1d90:	97ffffe4 	bl	1d20 <v8_flush_dcache_all>
	v8_invalidate_icache_all();
    1d94:	97fffffa 	bl	1d7c <v8_invalidate_icache_all>
}
    1d98:	a8c17bfd 	ldp	x29, x30, [sp], #16
    1d9c:	d65f03c0 	ret

0000000000001da0 <arm_early_mmu_cache_invalidate>:

void arm_early_mmu_cache_invalidate(void)
{
    1da0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    1da4:	910003fd 	mov	x29, sp
	v8_invalidate_dcache_all();
    1da8:	97ffffe3 	bl	1d34 <v8_invalidate_dcache_all>
	v8_invalidate_icache_all();
    1dac:	97fffff4 	bl	1d7c <v8_invalidate_icache_all>
}
    1db0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    1db4:	d65f03c0 	ret

0000000000001db8 <sync_caches_for_execution>:
 * Code has been modified in memory, call this before executing it.
 * This function flushes the data cache up to the point of unification
 * and invalidates the instruction cache.
 */
void sync_caches_for_execution(void)
{
    1db8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    1dbc:	910003fd 	mov	x29, sp
#ifndef __ASSEMBLY__
#if __LINUX_ARM_ARCH__ > 7
static inline unsigned int current_el(void)
{
	unsigned int el;
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    1dc0:	d5384240 	mrs	x0, currentel
	return el >> 2;
    1dc4:	53027c00 	lsr	w0, w0, #2
{
	unsigned int val;

#ifdef CONFIG_CPU_64v8
	unsigned int el = current_el();
	if (el == 1)
    1dc8:	7100041f 	cmp	w0, #0x1
    1dcc:	540000c1 	b.ne	1de4 <sync_caches_for_execution+0x2c>  // b.any
		asm volatile("mrs %0, sctlr_el1" : "=r" (val) : : "cc");
    1dd0:	d5381000 	mrs	x0, sctlr_el1
	/* if caches are disabled, don't do data cache maintenance */
	if (!(get_cr() & CR_C)) {
    1dd4:	37100140 	tbnz	w0, #2, 1dfc <sync_caches_for_execution+0x44>
static inline void icache_invalidate(void)
{
#if __LINUX_ARM_ARCH__ <= 7
	asm volatile("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
#else
	v8_invalidate_icache_all();
    1dd8:	97ffffe9 	bl	1d7c <v8_invalidate_icache_all>
	/*
	 * Despite the name arm_early_mmu_cache_flush not only flushes the
	 * data cache, but also invalidates the instruction cache.
	 */
	arm_early_mmu_cache_flush();
}
    1ddc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    1de0:	d65f03c0 	ret
	else if (el == 2)
    1de4:	7100081f 	cmp	w0, #0x2
    1de8:	54000061 	b.ne	1df4 <sync_caches_for_execution+0x3c>  // b.any
		asm volatile("mrs %0, sctlr_el2" : "=r" (val) : : "cc");
    1dec:	d53c1000 	mrs	x0, sctlr_el2
    1df0:	17fffff9 	b	1dd4 <sync_caches_for_execution+0x1c>
	else
		asm volatile("mrs %0, sctlr_el3" : "=r" (val) : : "cc");
    1df4:	d53e1000 	mrs	x0, sctlr_el3
    1df8:	17fffff7 	b	1dd4 <sync_caches_for_execution+0x1c>
	arm_early_mmu_cache_flush();
    1dfc:	97ffffe3 	bl	1d88 <arm_early_mmu_cache_flush>
    1e00:	17fffff7 	b	1ddc <sync_caches_for_execution+0x24>

0000000000001e04 <relocate_to_current_adr>:

/*
 * relocate binary to the currently running address
 */
void __prereloc relocate_to_current_adr(void)
{
    1e04:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    1e08:	910003fd 	mov	x29, sp
	unsigned long offset;
	unsigned long __maybe_unused *dynsym, *dynend;
	void *dstart, *dend;

	/* Get offset between linked address and runtime address */
	offset = get_runtime_offset();
    1e0c:	97fff8ad 	bl	c0 <get_runtime_offset>

	/*
	 * We have yet to relocate, so using runtime_address
	 * to compute the relocated address
	 */
	dstart = runtime_address(__rel_dyn_start);
    1e10:	d0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    1e14:	f9476c21 	ldr	x1, [x1, #3800]
    1e18:	f9000be1 	str	x1, [sp, #16]
    1e1c:	f9400be1 	ldr	x1, [sp, #16]
static inline __prereloc unsigned long global_variable_offset(void)
{
#ifdef CONFIG_CPU_V8
	unsigned long text;

	__asm__ __volatile__(
    1e20:	f0ffffe2 	adrp	x2, 0 <start_dt_2nd>
    1e24:	91000042 	add	x2, x2, #0x0
		"adrp   %0, _text\n"
		"add    %0, %0, :lo12:_text\n"
		: "=r" (text)
		:
		: "memory");
	return text - (unsigned long)_text;
    1e28:	d0000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    1e2c:	f9477c63 	ldr	x3, [x3, #3832]
    1e30:	8b020021 	add	x1, x1, x2
	dend = runtime_address(__rel_dyn_end);
    1e34:	d0000002 	adrp	x2, 3000 <lz4_decompress+0x324>
    1e38:	f9478042 	ldr	x2, [x2, #3840]
    1e3c:	f9000fe2 	str	x2, [sp, #24]
	dstart = runtime_address(__rel_dyn_start);
    1e40:	cb030021 	sub	x1, x1, x3
	dend = runtime_address(__rel_dyn_end);
    1e44:	f9400fe2 	ldr	x2, [sp, #24]
	__asm__ __volatile__(
    1e48:	f0ffffe4 	adrp	x4, 0 <start_dt_2nd>
    1e4c:	91000084 	add	x4, x4, #0x0
    1e50:	8b040042 	add	x2, x2, x4
    1e54:	cb030042 	sub	x2, x2, x3

#if defined(CONFIG_CPU_64)
	while (dstart < dend) {
    1e58:	eb02003f 	cmp	x1, x2
    1e5c:	54000083 	b.cc	1e6c <relocate_to_current_adr+0x68>  // b.lo, b.ul, b.last
	__memset(dynsym, 0, (unsigned long)dynend - (unsigned long)dynsym);
#else
#error "Architecture not specified"
#endif

	sync_caches_for_execution();
    1e60:	97ffffd6 	bl	1db8 <sync_caches_for_execution>
}
    1e64:	a8c27bfd 	ldp	x29, x30, [sp], #32
    1e68:	d65f03c0 	ret
		if (ELF64_R_TYPE(rel->r_info) == R_AARCH64_RELATIVE) {
    1e6c:	a9401c26 	ldp	x6, x7, [x1]
			*fixup = rel->r_addend + offset;
    1e70:	f9400823 	ldr	x3, [x1, #16]
		if (ELF64_R_TYPE(rel->r_info) == R_AARCH64_RELATIVE) {
    1e74:	71100cff 	cmp	w7, #0x403
    1e78:	540010e0 	b.eq	2094 <relocate_to_current_adr+0x290>  // b.none
    1e7c:	d2860180 	mov	x0, #0x300c                	// #12300
    1e80:	f2bff000 	movk	x0, #0xff80, lsl #16
    1e84:	b9400001 	ldr	w1, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1e88:	37afffe1 	tbnz	w1, #21, 1e84 <relocate_to_current_adr+0x80>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1e8c:	d2860002 	mov	x2, #0x3000                	// #12288
    1e90:	528007c1 	mov	w1, #0x3e                  	// #62
    1e94:	f2bff002 	movk	x2, #0xff80, lsl #16
    1e98:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1e9c:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1ea0:	36b7ffe1 	tbz	w1, #22, 1e9c <relocate_to_current_adr+0x98>
    1ea4:	d2860180 	mov	x0, #0x300c                	// #12300
    1ea8:	52800704 	mov	w4, #0x38                  	// #56
    1eac:	f2bff000 	movk	x0, #0xff80, lsl #16
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1eb0:	d1003008 	sub	x8, x0, #0xc
{
	int i; unsigned char ch;

	for (i = 2; i--; ) {
		ch = ((value >> (i * 4)) & 0xf);
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1eb4:	52800609 	mov	w9, #0x30                  	// #48
    1eb8:	52800aea 	mov	w10, #0x57                  	// #87
static inline void puthex_ll(unsigned long value)
{
	int i;

	for (i = sizeof(unsigned long); i--; )
		puthexc_ll(value >> (i * 8));
    1ebc:	9ac424e2 	lsr	x2, x7, x4
    1ec0:	12001c45 	and	w5, w2, #0xff
		ch = ((value >> (i * 4)) & 0xf);
    1ec4:	53041c42 	ubfx	w2, w2, #4, #4
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1ec8:	7100285f 	cmp	w2, #0xa
    1ecc:	1a8ab121 	csel	w1, w9, w10, lt	// lt = tstop
    1ed0:	0b020021 	add	w1, w1, w2
    1ed4:	13001c21 	sxtb	w1, w1
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1ed8:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1edc:	37afffe2 	tbnz	w2, #21, 1ed8 <relocate_to_current_adr+0xd4>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1ee0:	b9000101 	str	w1, [x8]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1ee4:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1ee8:	36b7ffe1 	tbz	w1, #22, 1ee4 <relocate_to_current_adr+0xe0>
		ch = ((value >> (i * 4)) & 0xf);
    1eec:	12000ca2 	and	w2, w5, #0xf
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1ef0:	7100285f 	cmp	w2, #0xa
    1ef4:	1a8a3121 	csel	w1, w9, w10, cc	// cc = lo, ul, last
    1ef8:	0b020021 	add	w1, w1, w2
    1efc:	13001c21 	sxtb	w1, w1
    1f00:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1f04:	37afffe2 	tbnz	w2, #21, 1f00 <relocate_to_current_adr+0xfc>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1f08:	b9000101 	str	w1, [x8]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1f0c:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1f10:	36b7ffe1 	tbz	w1, #22, 1f0c <relocate_to_current_adr+0x108>
	for (i = sizeof(unsigned long); i--; )
    1f14:	51002084 	sub	w4, w4, #0x8
    1f18:	3100209f 	cmn	w4, #0x8
    1f1c:	54fffd01 	b.ne	1ebc <relocate_to_current_adr+0xb8>  // b.any
    1f20:	d2860180 	mov	x0, #0x300c                	// #12300
    1f24:	f2bff000 	movk	x0, #0xff80, lsl #16
    1f28:	b9400001 	ldr	w1, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1f2c:	37afffe1 	tbnz	w1, #21, 1f28 <relocate_to_current_adr+0x124>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1f30:	d2860002 	mov	x2, #0x3000                	// #12288
    1f34:	52800401 	mov	w1, #0x20                  	// #32
    1f38:	f2bff002 	movk	x2, #0xff80, lsl #16
    1f3c:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1f40:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1f44:	36b7ffe1 	tbz	w1, #22, 1f40 <relocate_to_current_adr+0x13c>
    1f48:	d2860180 	mov	x0, #0x300c                	// #12300
    1f4c:	52800704 	mov	w4, #0x38                  	// #56
    1f50:	f2bff000 	movk	x0, #0xff80, lsl #16
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1f54:	d1003007 	sub	x7, x0, #0xc
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1f58:	52800608 	mov	w8, #0x30                  	// #48
    1f5c:	52800ae9 	mov	w9, #0x57                  	// #87
		puthexc_ll(value >> (i * 8));
    1f60:	9ac424c2 	lsr	x2, x6, x4
    1f64:	12001c45 	and	w5, w2, #0xff
		ch = ((value >> (i * 4)) & 0xf);
    1f68:	53041c42 	ubfx	w2, w2, #4, #4
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1f6c:	7100285f 	cmp	w2, #0xa
    1f70:	1a89b101 	csel	w1, w8, w9, lt	// lt = tstop
    1f74:	0b020021 	add	w1, w1, w2
    1f78:	13001c21 	sxtb	w1, w1
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1f7c:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1f80:	37afffe2 	tbnz	w2, #21, 1f7c <relocate_to_current_adr+0x178>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1f84:	b90000e1 	str	w1, [x7]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1f88:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1f8c:	36b7ffe1 	tbz	w1, #22, 1f88 <relocate_to_current_adr+0x184>
		ch = ((value >> (i * 4)) & 0xf);
    1f90:	12000ca2 	and	w2, w5, #0xf
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1f94:	7100285f 	cmp	w2, #0xa
    1f98:	1a893101 	csel	w1, w8, w9, cc	// cc = lo, ul, last
    1f9c:	0b020021 	add	w1, w1, w2
    1fa0:	13001c21 	sxtb	w1, w1
    1fa4:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1fa8:	37afffe2 	tbnz	w2, #21, 1fa4 <relocate_to_current_adr+0x1a0>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1fac:	b90000e1 	str	w1, [x7]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1fb0:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1fb4:	36b7ffe1 	tbz	w1, #22, 1fb0 <relocate_to_current_adr+0x1ac>
	for (i = sizeof(unsigned long); i--; )
    1fb8:	51002084 	sub	w4, w4, #0x8
    1fbc:	3100209f 	cmn	w4, #0x8
    1fc0:	54fffd01 	b.ne	1f60 <relocate_to_current_adr+0x15c>  // b.any
    1fc4:	d2860180 	mov	x0, #0x300c                	// #12300
    1fc8:	f2bff000 	movk	x0, #0xff80, lsl #16
    1fcc:	b9400001 	ldr	w1, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    1fd0:	37afffe1 	tbnz	w1, #21, 1fcc <relocate_to_current_adr+0x1c8>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1fd4:	d2860002 	mov	x2, #0x3000                	// #12288
    1fd8:	52800401 	mov	w1, #0x20                  	// #32
    1fdc:	f2bff002 	movk	x2, #0xff80, lsl #16
    1fe0:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    1fe4:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    1fe8:	36b7ffe1 	tbz	w1, #22, 1fe4 <relocate_to_current_adr+0x1e0>
    1fec:	d2860180 	mov	x0, #0x300c                	// #12300
    1ff0:	52800704 	mov	w4, #0x38                  	// #56
    1ff4:	f2bff000 	movk	x0, #0xff80, lsl #16
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    1ff8:	d1003006 	sub	x6, x0, #0xc
		ch += (ch >= 10) ? 'a' - 10 : '0';
    1ffc:	52800607 	mov	w7, #0x30                  	// #48
    2000:	52800ae8 	mov	w8, #0x57                  	// #87
		puthexc_ll(value >> (i * 8));
    2004:	9ac42462 	lsr	x2, x3, x4
    2008:	12001c45 	and	w5, w2, #0xff
		ch = ((value >> (i * 4)) & 0xf);
    200c:	53041c42 	ubfx	w2, w2, #4, #4
		ch += (ch >= 10) ? 'a' - 10 : '0';
    2010:	7100285f 	cmp	w2, #0xa
    2014:	1a88b0e1 	csel	w1, w7, w8, lt	// lt = tstop
    2018:	0b020021 	add	w1, w1, w2
    201c:	13001c21 	sxtb	w1, w1
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2020:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2024:	37afffe2 	tbnz	w2, #21, 2020 <relocate_to_current_adr+0x21c>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2028:	b90000c1 	str	w1, [x6]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    202c:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2030:	36b7ffe1 	tbz	w1, #22, 202c <relocate_to_current_adr+0x228>
		ch = ((value >> (i * 4)) & 0xf);
    2034:	12000ca2 	and	w2, w5, #0xf
		ch += (ch >= 10) ? 'a' - 10 : '0';
    2038:	7100285f 	cmp	w2, #0xa
    203c:	1a8830e1 	csel	w1, w7, w8, cc	// cc = lo, ul, last
    2040:	0b020021 	add	w1, w1, w2
    2044:	13001c21 	sxtb	w1, w1
    2048:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    204c:	37afffe2 	tbnz	w2, #21, 2048 <relocate_to_current_adr+0x244>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2050:	b90000c1 	str	w1, [x6]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2054:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2058:	36b7ffe1 	tbz	w1, #22, 2054 <relocate_to_current_adr+0x250>
	for (i = sizeof(unsigned long); i--; )
    205c:	51002084 	sub	w4, w4, #0x8
    2060:	3100209f 	cmn	w4, #0x8
    2064:	54fffd01 	b.ne	2004 <relocate_to_current_adr+0x200>  // b.any
    2068:	d2860180 	mov	x0, #0x300c                	// #12300
    206c:	f2bff000 	movk	x0, #0xff80, lsl #16
    2070:	b9400001 	ldr	w1, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2074:	37afffe1 	tbnz	w1, #21, 2070 <relocate_to_current_adr+0x26c>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2078:	d2860002 	mov	x2, #0x3000                	// #12288
    207c:	52800141 	mov	w1, #0xa                   	// #10
    2080:	f2bff002 	movk	x2, #0xff80, lsl #16
    2084:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2088:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    208c:	36b7ffe1 	tbz	w1, #22, 2088 <relocate_to_current_adr+0x284>
    2090:	14000000 	b	2090 <relocate_to_current_adr+0x28c>
			*fixup = rel->r_addend + offset;
    2094:	8b030003 	add	x3, x0, x3
    2098:	f8266803 	str	x3, [x0, x6]
			rel->r_addend += offset;
    209c:	f9400823 	ldr	x3, [x1, #16]
    20a0:	8b000063 	add	x3, x3, x0
    20a4:	f9000823 	str	x3, [x1, #16]
			rel->r_offset += offset;
    20a8:	f9400023 	ldr	x3, [x1]
    20ac:	8b000063 	add	x3, x3, x0
    20b0:	f8018423 	str	x3, [x1], #24
		dstart += sizeof(*rel);
    20b4:	17ffff69 	b	1e58 <relocate_to_current_adr+0x54>

00000000000020b8 <barebox_arm_entry>:
				    void *boarddata,
				    unsigned long sp);

void NAKED __noreturn barebox_arm_entry(unsigned long membase,
					unsigned long memsize, void *boarddata)
{
    20b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	return endmem;
}

static inline unsigned long arm_mem_stack_top(unsigned long endmem)
{
	return arm_mem_stack(endmem) + STACK_SIZE;
    20bc:	d1402023 	sub	x3, x1, #0x8, lsl #12
	__barebox_arm_entry(membase, memsize, boarddata,
    20c0:	8b000063 	add	x3, x3, x0
{
    20c4:	910003fd 	mov	x29, sp
	__barebox_arm_entry(membase, memsize, boarddata,
    20c8:	94000001 	bl	20cc <__barebox_arm_entry>

00000000000020cc <__barebox_arm_entry>:
    20cc:	d65f03c0 	ret
    20d0:	9100007f 	mov	sp, x3
    20d4:	aa0003f3 	mov	x19, x0
    20d8:	aa0103f4 	mov	x20, x1
    20dc:	aa0203f5 	mov	x21, x2
    20e0:	97ffff30 	bl	1da0 <arm_early_mmu_cache_invalidate>
    20e4:	aa1303e0 	mov	x0, x19
    20e8:	aa1403e1 	mov	x1, x20
    20ec:	aa1503e2 	mov	x2, x21
    20f0:	140001de 	b	2868 <barebox_pbl_start>
    20f4:	d65f03c0 	ret

00000000000020f8 <get_ttb>:
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    20f8:	d5384240 	mrs	x0, currentel
	return el >> 2;
    20fc:	53027c00 	lsr	w0, w0, #2
}

static inline uint64_t get_ttbr(int el)
{
	uint64_t val;
	if (el == 1) {
    2100:	7100041f 	cmp	w0, #0x1
    2104:	54000061 	b.ne	2110 <get_ttb+0x18>  // b.any
		asm volatile("mrs %0, ttbr0_el1" : "=r" (val));
    2108:	d5382000 	mrs	x0, ttbr0_el1
    210c:	d65f03c0 	ret
	} else if (el == 2) {
    2110:	7100081f 	cmp	w0, #0x2
    2114:	54000061 	b.ne	2120 <get_ttb+0x28>  // b.any
		asm volatile("mrs %0, ttbr0_el2" : "=r" (val));
    2118:	d53c2000 	mrs	x0, ttbr0_el2
    211c:	d65f03c0 	ret
	} else if (el == 3) {
    2120:	71000c1f 	cmp	w0, #0x3
    2124:	54000061 	b.ne	2130 <get_ttb+0x38>  // b.any
		asm volatile("mrs %0, ttbr0_el3" : "=r" (val));
    2128:	d53e2000 	mrs	x0, ttbr0_el3
}

static uint64_t *get_ttb(void)
{
	return (uint64_t *)get_ttbr(current_el());
}
    212c:	d65f03c0 	ret
{
    2130:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    2134:	910003fd 	mov	x29, sp
	} else {
		hang();
    2138:	94000566 	bl	36d0 <hang>

000000000000213c <dma_flush_range>:

	v8_inv_dcache_range(start, end);
}

void dma_flush_range(void *ptr, size_t size)
{
    213c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	unsigned long start = (unsigned long)ptr;
	unsigned long end = start + size;

	v8_flush_dcache_range(start, end);
    2140:	8b010001 	add	x1, x0, x1
{
    2144:	910003fd 	mov	x29, sp
	v8_flush_dcache_range(start, end);
    2148:	97ffff00 	bl	1d48 <v8_flush_dcache_range>
}
    214c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    2150:	d65f03c0 	ret

0000000000002154 <set_pte_range.isra.0>:
static void set_pte_range(unsigned level, uint64_t *virt, phys_addr_t phys,
    2154:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    2158:	2a0003e5 	mov	w5, w0
    215c:	aa0103e0 	mov	x0, x1
    2160:	910003fd 	mov	x29, sp
    2164:	510004a1 	sub	w1, w5, #0x1
    2168:	7100083f 	cmp	w1, #0x2
    216c:	54000268 	b.hi	21b8 <set_pte_range.isra.0+0x64>  // b.pmore
    2170:	b0000005 	adrp	x5, 3000 <lz4_decompress+0x324>
    2174:	912e80a5 	add	x5, x5, #0xba0
    2178:	b86158a6 	ldr	w6, [x5, w1, uxtw #2]
	for (int i = 0; i < count; i++, phys += granularity)
    217c:	92407cc6 	and	x6, x6, #0xffffffff
static void set_pte_range(unsigned level, uint64_t *virt, phys_addr_t phys,
    2180:	52800001 	mov	w1, #0x0                   	// #0
	for (int i = 0; i < count; i++, phys += granularity)
    2184:	d2800005 	mov	x5, #0x0                   	// #0
		set_pte(&virt[i], phys | attrs);
    2188:	d37df0a5 	lsl	x5, x5, #3
	for (int i = 0; i < count; i++, phys += granularity)
    218c:	11000421 	add	w1, w1, #0x1
		set_pte(&virt[i], phys | attrs);
    2190:	aa020087 	orr	x7, x4, x2
	for (int i = 0; i < count; i++, phys += granularity)
    2194:	8b060042 	add	x2, x2, x6
	WRITE_ONCE(*pt, val);
    2198:	f8256807 	str	x7, [x0, x5]
	for (int i = 0; i < count; i++, phys += granularity)
    219c:	93407c25 	sxtw	x5, w1
    21a0:	eb21c07f 	cmp	x3, w1, sxtw
    21a4:	54ffff28 	b.hi	2188 <set_pte_range.isra.0+0x34>  // b.pmore
	dma_flush_range(virt, count * sizeof(*virt));
    21a8:	d37df061 	lsl	x1, x3, #3
    21ac:	97ffffe4 	bl	213c <dma_flush_range>
}
    21b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    21b4:	d65f03c0 	ret
static void set_pte_range(unsigned level, uint64_t *virt, phys_addr_t phys,
    21b8:	d2c01006 	mov	x6, #0x8000000000          	// #549755813888
    21bc:	17fffff0 	b	217c <set_pte_range.isra.0+0x28>

00000000000021c0 <split_block.isra.0>:
static void split_block(uint64_t *pte, int level, bool bbm)
    21c0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    21c4:	910003fd 	mov	x29, sp
    21c8:	a90153f3 	stp	x19, x20, [sp, #16]
    21cc:	a9025bf5 	stp	x21, x22, [sp, #32]
    21d0:	aa0003f5 	mov	x21, x0
    21d4:	f9001bf7 	str	x23, [sp, #48]
	uint64_t old_pte = *pte;
    21d8:	f9400017 	ldr	x23, [x0]
	if ((*pte & PTE_TYPE_MASK) == PTE_TYPE_TABLE)
    21dc:	924006e0 	and	x0, x23, #0x3
    21e0:	f1000c1f 	cmp	x0, #0x3
    21e4:	540004a0 	b.eq	2278 <split_block.isra.0+0xb8>  // b.none
	idx++;
    21e8:	d0000000 	adrp	x0, 4000 <__rel_dyn_start+0xb8>
    21ec:	b9405013 	ldr	w19, [x0, #80]
    21f0:	11000673 	add	w19, w19, #0x1
    21f4:	b9005013 	str	w19, [x0, #80]
	BUG_ON(idx * GRANULE_SIZE >= ARM_EARLY_PAGETABLE_SIZE);
    21f8:	12bfff80 	mov	w0, #0x3ffff               	// #262143
    21fc:	53144e73 	lsl	w19, w19, #12
    2200:	6b00027f 	cmp	w19, w0
    2204:	54000189 	b.ls	2234 <split_block.isra.0+0x74>  // b.plast
    2208:	b0000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    220c:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    2210:	912ef063 	add	x3, x3, #0xbbc
    2214:	9124ec21 	add	x1, x1, #0x93b
    2218:	52800ba2 	mov	w2, #0x5d                  	// #93
    221c:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    2220:	91254400 	add	x0, x0, #0x951
    2224:	94000216 	bl	2a7c <printf>
    2228:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    222c:	9125b800 	add	x0, x0, #0x96e
    2230:	94000529 	bl	36d4 <panic>
    2234:	2a0103f4 	mov	w20, w1
	return (void *)get_ttb() + idx * GRANULE_SIZE;
    2238:	97ffffb0 	bl	20f8 <get_ttb>
	u64 flags = 0;
    223c:	71000a9f 	cmp	w20, #0x2
	return (void *)get_ttb() + idx * GRANULE_SIZE;
    2240:	8b334013 	add	x19, x0, w19, uxtw
	set_pte_range(level + 1, new_table, old_pte, MAX_PTE_ENTRIES, flags, bbm);
    2244:	aa1703e2 	mov	x2, x23
    2248:	aa1303e1 	mov	x1, x19
    224c:	11000680 	add	w0, w20, #0x1
	u64 flags = 0;
    2250:	d2800076 	mov	x22, #0x3                   	// #3
	set_pte_range(level + 1, new_table, old_pte, MAX_PTE_ENTRIES, flags, bbm);
    2254:	d2804003 	mov	x3, #0x200                 	// #512
    2258:	9a9f02c4 	csel	x4, x22, xzr, eq	// eq = none
    225c:	97ffffbe 	bl	2154 <set_pte_range.isra.0>
	set_pte_range(level, pte, (uint64_t)new_table, 1, PTE_TYPE_TABLE, bbm);
    2260:	aa1603e4 	mov	x4, x22
    2264:	aa1303e2 	mov	x2, x19
    2268:	aa1503e1 	mov	x1, x21
    226c:	2a1403e0 	mov	w0, w20
    2270:	d2800023 	mov	x3, #0x1                   	// #1
    2274:	97ffffb8 	bl	2154 <set_pte_range.isra.0>
}
    2278:	a94153f3 	ldp	x19, x20, [sp, #16]
    227c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    2280:	f9401bf7 	ldr	x23, [sp, #48]
    2284:	a8c47bfd 	ldp	x29, x30, [sp], #64
    2288:	d65f03c0 	ret

000000000000228c <__arch_remap_range.isra.0>:
static int __arch_remap_range(uint64_t virt, uint64_t phys, uint64_t size,
    228c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    2290:	910003fd 	mov	x29, sp
    2294:	a90153f3 	stp	x19, x20, [sp, #16]
    2298:	aa0003f4 	mov	x20, x0
	switch (map_type & MAP_TYPE_MASK) {
    229c:	12003c60 	and	w0, w3, #0xffff
static int __arch_remap_range(uint64_t virt, uint64_t phys, uint64_t size,
    22a0:	a9025bf5 	stp	x21, x22, [sp, #32]
    22a4:	aa0103f5 	mov	x21, x1
    22a8:	2a0303f6 	mov	w22, w3
    22ac:	a90363f7 	stp	x23, x24, [sp, #48]
    22b0:	a9046bf9 	stp	x25, x26, [sp, #64]
    22b4:	a90573fb 	stp	x27, x28, [sp, #80]
    22b8:	aa0203fb 	mov	x27, x2
	switch (map_type & MAP_TYPE_MASK) {
    22bc:	71000c1f 	cmp	w0, #0x3
    22c0:	540009a0 	b.eq	23f4 <__arch_remap_range.isra.0+0x168>  // b.none
    22c4:	721e347f 	tst	w3, #0xfffc
    22c8:	540000e1 	b.ne	22e4 <__arch_remap_range.isra.0+0x58>  // b.any
    22cc:	7100041f 	cmp	w0, #0x1
    22d0:	54000480 	b.eq	2360 <__arch_remap_range.isra.0+0xd4>  // b.none
    22d4:	7100081f 	cmp	w0, #0x2
    22d8:	54000581 	b.ne	2388 <__arch_remap_range.isra.0+0xfc>  // b.any
		return 0x0;
    22dc:	d2800013 	mov	x19, #0x0                   	// #0
    22e0:	1400000a 	b	2308 <__arch_remap_range.isra.0+0x7c>
	switch (map_type & MAP_TYPE_MASK) {
    22e4:	529fff81 	mov	w1, #0xfffc                	// #65532
    22e8:	6b01001f 	cmp	w0, w1
    22ec:	54000720 	b.eq	23d0 <__arch_remap_range.isra.0+0x144>  // b.none
    22f0:	529fffa1 	mov	w1, #0xfffd                	// #65533
    22f4:	6b01001f 	cmp	w0, w1
    22f8:	54000820 	b.eq	23fc <__arch_remap_range.isra.0+0x170>  // b.none
    22fc:	7100101f 	cmp	w0, #0x4
    2300:	54000560 	b.eq	23ac <__arch_remap_range.isra.0+0x120>  // b.none
		return ~0UL;
    2304:	92800013 	mov	x19, #0xffffffffffffffff    	// #-1
	uint64_t *ttb = get_ttb();
    2308:	97ffff7c 	bl	20f8 <get_ttb>
    230c:	aa0003f8 	mov	x24, x0
	if (WARN_ON(attr == ~0UL))
    2310:	b100067f 	cmn	x19, #0x1
    2314:	54000780 	b.eq	2404 <__arch_remap_range.isra.0+0x178>  // b.none
	size = PAGE_ALIGN(size);
    2318:	913fff7b 	add	x27, x27, #0xfff
	if (!size)
    231c:	f274cf7b 	ands	x27, x27, #0xfffffffffffff000
    2320:	540001c0 	b.eq	2358 <__arch_remap_range.isra.0+0xcc>  // b.none
    2324:	b000001a 	adrp	x26, 3000 <lz4_decompress+0x324>
	bool force_pages = map_type & ARCH_MAP_FLAG_PAGEWISE;
    2328:	531f7ed9 	lsr	w25, w22, #31
	attr &= ~PTE_TYPE_MASK;
    232c:	927ef673 	and	x19, x19, #0xfffffffffffffffc
    2330:	912e235a 	add	x26, x26, #0xb88
	while (size) {
    2334:	b5000c9b 	cbnz	x27, 24c4 <__arch_remap_range.isra.0+0x238>
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    2338:	d5384240 	mrs	x0, currentel
	return el >> 2;
    233c:	53027c00 	lsr	w0, w0, #2
	dsb();
    2340:	d5033f9f 	dsb	sy
	if (el == 1)
    2344:	7100041f 	cmp	w0, #0x1
    2348:	54001101 	b.ne	2568 <__arch_remap_range.isra.0+0x2dc>  // b.any
		__asm__ __volatile__("tlbi vmalle1\n\t" : : : "memory");
    234c:	d508871f 	tlbi	vmalle1
	dsb();
    2350:	d5033f9f 	dsb	sy
	isb();
    2354:	d5033fdf 	isb
		return 0;
    2358:	52800000 	mov	w0, #0x0                   	// #0
    235c:	14000033 	b	2428 <__arch_remap_range.isra.0+0x19c>
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    2360:	d5384240 	mrs	x0, currentel
	return el >> 2;
    2364:	53027c00 	lsr	w0, w0, #2
		return PTE_BLOCK_UXN;
    2368:	d2e00c13 	mov	x19, #0x60000000000000      	// #27021597764222976
	switch (current_el()) {
    236c:	51000800 	sub	w0, w0, #0x2
		return PTE_BLOCK_UXN;
    2370:	7100041f 	cmp	w0, #0x1
    2374:	d2e00800 	mov	x0, #0x40000000000000      	// #18014398509481984
    2378:	9a808273 	csel	x19, x19, x0, hi	// hi = pmore
		return attrs_xn() | CACHED_MEM;
    237c:	d280c200 	mov	x0, #0x610                 	// #1552
		return attrs_xn() | CACHED_MEM | PTE_BLOCK_RO;
    2380:	aa000273 	orr	x19, x19, x0
    2384:	17ffffe1 	b	2308 <__arch_remap_range.isra.0+0x7c>
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    2388:	d5384240 	mrs	x0, currentel
	return el >> 2;
    238c:	53027c00 	lsr	w0, w0, #2
    2390:	d2e00c13 	mov	x19, #0x60000000000000      	// #27021597764222976
	switch (current_el()) {
    2394:	51000800 	sub	w0, w0, #0x2
		return PTE_BLOCK_UXN;
    2398:	7100041f 	cmp	w0, #0x1
    239c:	d2e00800 	mov	x0, #0x40000000000000      	// #18014398509481984
    23a0:	9a808273 	csel	x19, x19, x0, hi	// hi = pmore
		return attrs_xn() | UNCACHED_MEM;
    23a4:	b2770673 	orr	x19, x19, #0x600
    23a8:	17ffffd8 	b	2308 <__arch_remap_range.isra.0+0x7c>
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    23ac:	d5384240 	mrs	x0, currentel
	return el >> 2;
    23b0:	53027c00 	lsr	w0, w0, #2
    23b4:	d2e00c13 	mov	x19, #0x60000000000000      	// #27021597764222976
	switch (current_el()) {
    23b8:	51000800 	sub	w0, w0, #0x2
		return PTE_BLOCK_UXN;
    23bc:	7100041f 	cmp	w0, #0x1
    23c0:	d2e00800 	mov	x0, #0x40000000000000      	// #18014398509481984
    23c4:	9a808273 	csel	x19, x19, x0, hi	// hi = pmore
		return attrs_xn() | MEM_ALLOC_WRITECOMBINE;
    23c8:	d280c180 	mov	x0, #0x60c                 	// #1548
    23cc:	17ffffed 	b	2380 <__arch_remap_range.isra.0+0xf4>
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    23d0:	d5384240 	mrs	x0, currentel
	return el >> 2;
    23d4:	53027c00 	lsr	w0, w0, #2
    23d8:	d2e00c13 	mov	x19, #0x60000000000000      	// #27021597764222976
	switch (current_el()) {
    23dc:	51000800 	sub	w0, w0, #0x2
		return PTE_BLOCK_UXN;
    23e0:	7100041f 	cmp	w0, #0x1
    23e4:	d2e00800 	mov	x0, #0x40000000000000      	// #18014398509481984
    23e8:	9a808273 	csel	x19, x19, x0, hi	// hi = pmore
		return attrs_xn() | CACHED_MEM | PTE_BLOCK_RO;
    23ec:	d280d200 	mov	x0, #0x690                 	// #1680
    23f0:	17ffffe4 	b	2380 <__arch_remap_range.isra.0+0xf4>
	switch (map_type & MAP_TYPE_MASK) {
    23f4:	d280d213 	mov	x19, #0x690                 	// #1680
    23f8:	17ffffc4 	b	2308 <__arch_remap_range.isra.0+0x7c>
		return CACHED_MEM;
    23fc:	d280c213 	mov	x19, #0x610                 	// #1552
    2400:	17ffffc2 	b	2308 <__arch_remap_range.isra.0+0x7c>
	if (WARN_ON(attr == ~0UL))
    2404:	b0000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    2408:	52801a82 	mov	w2, #0xd4                  	// #212
    240c:	912f1863 	add	x3, x3, #0xbc6
    2410:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    2414:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    2418:	9124ec21 	add	x1, x1, #0x93b
    241c:	9125cc00 	add	x0, x0, #0x973
    2420:	94000197 	bl	2a7c <printf>
		return -EINVAL;
    2424:	128002a0 	mov	w0, #0xffffffea            	// #-22
}
    2428:	a94153f3 	ldp	x19, x20, [sp, #16]
    242c:	a9425bf5 	ldp	x21, x22, [sp, #32]
    2430:	a94363f7 	ldp	x23, x24, [sp, #48]
    2434:	a9446bf9 	ldp	x25, x26, [sp, #64]
    2438:	a94573fb 	ldp	x27, x28, [sp, #80]
    243c:	a8c77bfd 	ldp	x29, x30, [sp], #112
    2440:	d65f03c0 	ret
		table = ttb;
    2444:	b27423f7 	mov	x23, #0x1ff000              	// #2093056
    2448:	14000028 	b	24e8 <__arch_remap_range.isra.0+0x25c>
				        IS_ALIGNED(addr, block_size) &&
    244c:	52800001 	mov	w1, #0x0                   	// #0
    2450:	14000032 	b	2518 <__arch_remap_range.isra.0+0x28c>
    2454:	d2820005 	mov	x5, #0x1000                	// #4096
    2458:	52800060 	mov	w0, #0x3                   	// #3
					PTE_TYPE_PAGE : PTE_TYPE_BLOCK;
    245c:	d2800064 	mov	x4, #0x3                   	// #3
    2460:	14000037 	b	253c <__arch_remap_range.isra.0+0x2b0>
				split_block(pte, level, bbm);
    2464:	2a0003e1 	mov	w1, w0
    2468:	aa1703e0 	mov	x0, x23
    246c:	97ffff55 	bl	21c0 <split_block.isra.0>
	return *pte & PTE_TYPE_MASK;
}

static inline uint64_t *get_level_table(uint64_t *pte)
{
	uint64_t *table = (uint64_t *)(*pte & XLAT_ADDR_MASK);
    2470:	f94002e0 	ldr	x0, [x23]

	if (pte_type(pte) != PTE_TYPE_TABLE)
    2474:	12800102 	mov	w2, #0xfffffff7            	// #-9
    2478:	d2800023 	mov	x3, #0x1                   	// #1
	uint64_t *table = (uint64_t *)(*pte & XLAT_ADDR_MASK);
    247c:	92748c04 	and	x4, x0, #0xfffffffff000
	return *pte & PTE_TYPE_MASK;
    2480:	12000400 	and	w0, w0, #0x3
	if (pte_type(pte) != PTE_TYPE_TABLE)
    2484:	71000c1f 	cmp	w0, #0x3
    2488:	54000180 	b.eq	24b8 <__arch_remap_range.isra.0+0x22c>  // b.none
		BUG();
    248c:	b0000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    2490:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    2494:	912eb063 	add	x3, x3, #0xbac
    2498:	91263021 	add	x1, x1, #0x98c
    249c:	52801322 	mov	w2, #0x99                  	// #153
    24a0:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    24a4:	91254400 	add	x0, x0, #0x951
    24a8:	94000175 	bl	2a7c <printf>
    24ac:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    24b0:	9125b800 	add	x0, x0, #0x96e
    24b4:	94000488 	bl	36d4 <panic>
		for (level = 0; level < 4; level++) {
    24b8:	9100079c 	add	x28, x28, #0x1
    24bc:	f100139f 	cmp	x28, #0x4
    24c0:	540000a1 	b.ne	24d4 <__arch_remap_range.isra.0+0x248>  // b.any
		table = ttb;
    24c4:	aa1803e4 	mov	x4, x24
    24c8:	d280001c 	mov	x28, #0x0                   	// #0
    24cc:	12800102 	mov	w2, #0xfffffff7            	// #-9
			block_size = (1ULL << block_shift);
    24d0:	d2800023 	mov	x3, #0x1                   	// #1
    24d4:	2a1c03e1 	mov	w1, w28
    24d8:	2a1c03e0 	mov	w0, w28
	if (level == 0)
    24dc:	f1000f9f 	cmp	x28, #0x3
    24e0:	54fffb20 	b.eq	2444 <__arch_remap_range.isra.0+0x1b8>  // b.none
    24e4:	f87c7b57 	ldr	x23, [x26, x28, lsl #3]
	return mask;
    24e8:	1b027c21 	mul	w1, w1, w2
			idx = (addr & level2mask(level)) >> block_shift;
    24ec:	8a1402f7 	and	x23, x23, x20
    24f0:	11009c21 	add	w1, w1, #0x27
    24f4:	9ac126f7 	lsr	x23, x23, x1
			pte = table + idx;
    24f8:	8b170c97 	add	x23, x4, x23, lsl #3
			block_size = (1ULL << block_shift);
    24fc:	9ac12065 	lsl	x5, x3, x1
				        IS_ALIGNED(addr, block_size) &&
    2500:	eb1b00bf 	cmp	x5, x27
    2504:	54fffa48 	b.hi	244c <__arch_remap_range.isra.0+0x1c0>  // b.pmore
    2508:	aa1402a1 	orr	x1, x21, x20
    250c:	d10004a4 	sub	x4, x5, #0x1
    2510:	ea04003f 	tst	x1, x4
    2514:	1a9f17e1 	cset	w1, eq	// eq = none
			if ((force_pages && level == 3) || (!force_pages && block_aligned)) {
    2518:	7100033f 	cmp	w25, #0x0
    251c:	7a431b80 	ccmp	w28, #0x3, #0x0, ne	// ne = any
    2520:	54fff9a0 	b.eq	2454 <__arch_remap_range.isra.0+0x1c8>  // b.none
    2524:	710002df 	cmp	w22, #0x0
    2528:	7a40a824 	ccmp	w1, #0x0, #0x4, ge	// ge = tcont
    252c:	54fff9c0 	b.eq	2464 <__arch_remap_range.isra.0+0x1d8>  // b.none
					PTE_TYPE_PAGE : PTE_TYPE_BLOCK;
    2530:	71000c1f 	cmp	w0, #0x3
    2534:	d2800064 	mov	x4, #0x3                   	// #3
    2538:	9a9f0484 	csinc	x4, x4, xzr, eq	// eq = none
				set_pte_range(level, pte, phys, 1, attr | type, bbm);
    253c:	aa1503e2 	mov	x2, x21
    2540:	aa040264 	orr	x4, x19, x4
    2544:	aa1703e1 	mov	x1, x23
    2548:	d2800023 	mov	x3, #0x1                   	// #1
    254c:	f90037e5 	str	x5, [sp, #104]
    2550:	97ffff01 	bl	2154 <set_pte_range.isra.0>
				addr += block_size;
    2554:	f94037e5 	ldr	x5, [sp, #104]
    2558:	8b050294 	add	x20, x20, x5
				phys += block_size;
    255c:	8b0502b5 	add	x21, x21, x5
				size -= block_size;
    2560:	cb05037b 	sub	x27, x27, x5
				break;
    2564:	17ffff74 	b	2334 <__arch_remap_range.isra.0+0xa8>
	else if (el == 2)
    2568:	7100081f 	cmp	w0, #0x2
    256c:	54000061 	b.ne	2578 <__arch_remap_range.isra.0+0x2ec>  // b.any
		__asm__ __volatile__("tlbi alle2\n\t" : : : "memory");
    2570:	d50c871f 	tlbi	alle2
    2574:	17ffff77 	b	2350 <__arch_remap_range.isra.0+0xc4>
	else if (el == 3)
    2578:	71000c1f 	cmp	w0, #0x3
    257c:	54ffeea1 	b.ne	2350 <__arch_remap_range.isra.0+0xc4>  // b.any
		__asm__ __volatile__("tlbi alle3\n\t" : : : "memory");
    2580:	d50e871f 	tlbi	alle3
    2584:	17ffff73 	b	2350 <__arch_remap_range.isra.0+0xc4>

0000000000002588 <early_remap_range>:
{
    2588:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	__arch_remap_range(addr, addr, size, map_type, false);
    258c:	2a0203e3 	mov	w3, w2
    2590:	aa0103e2 	mov	x2, x1
{
    2594:	910003fd 	mov	x29, sp
	__arch_remap_range(addr, addr, size, map_type, false);
    2598:	aa0003e1 	mov	x1, x0
    259c:	97ffff3c 	bl	228c <__arch_remap_range.isra.0>
}
    25a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    25a4:	d65f03c0 	ret

00000000000025a8 <mmu_early_enable>:
		ttb++;
	}
}

void mmu_early_enable(unsigned long membase, unsigned long memsize, unsigned long barebox_start)
{
    25a8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    25ac:	910003fd 	mov	x29, sp
    25b0:	a90153f3 	stp	x19, x20, [sp, #16]
    25b4:	aa0203f3 	mov	x19, x2
    25b8:	a9025bf5 	stp	x21, x22, [sp, #32]
    25bc:	aa0003f5 	mov	x21, x0
    25c0:	aa0103f6 	mov	x22, x1
    25c4:	f9001bf7 	str	x23, [sp, #48]
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    25c8:	d5384240 	mrs	x0, currentel
	return el >> 2;
    25cc:	53027c00 	lsr	w0, w0, #2
	if (el == 1)
    25d0:	7100041f 	cmp	w0, #0x1
    25d4:	54000b01 	b.ne	2734 <mmu_early_enable+0x18c>  // b.any
		asm volatile("mrs %0, sctlr_el1" : "=r" (val) : : "cc");
    25d8:	d5381003 	mrs	x3, sctlr_el1
	unsigned long barebox_size;
	unsigned long ttb = arm_mem_ttb(membase + memsize);

	//return;

	if (get_cr() & CR_M)
    25dc:	37000a23 	tbnz	w3, #0, 2720 <mmu_early_enable+0x178>
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    25e0:	d5384245 	mrs	x5, currentel
	return el >> 2;
    25e4:	53027ca5 	lsr	w5, w5, #2
	unsigned long ttb = arm_mem_ttb(membase + memsize);
    25e8:	8b1602b4 	add	x20, x21, x22
		tcr = (ips << 32) | TCR_EPD1_DISABLE;
    25ec:	710004bf 	cmp	w5, #0x1
    25f0:	d2a00043 	mov	x3, #0x20000               	// #131072
    25f4:	d2a01000 	mov	x0, #0x800000              	// #8388608
	tcr |= TCR_T0SZ(va_bits);
    25f8:	d286a202 	mov	x2, #0x3510                	// #13584
		tcr = (ips << 32) | TCR_EPD1_DISABLE;
    25fc:	f2c00040 	movk	x0, #0x2, lsl #32
    2600:	9a801064 	csel	x4, x3, x0, ne	// ne = any
	return arm_mem_scratch(endmem) - STACK_SIZE;
    2604:	d1404283 	sub	x3, x20, #0x10, lsl #12
	return ALIGN_DOWN(endmem, PAGE_SIZE) - PAGE_SIZE;
    2608:	9274cc63 	and	x3, x3, #0xfffffffffffff000
    260c:	d1400463 	sub	x3, x3, #0x1, lsl #12
	endmem = ALIGN_DOWN(endmem, ARM_EARLY_PAGETABLE_SIZE) - ARM_EARLY_PAGETABLE_SIZE;
    2610:	926eb463 	and	x3, x3, #0xfffffffffffc0000
    2614:	d1410060 	sub	x0, x3, #0x40, lsl #12
	tcr |= TCR_T0SZ(va_bits);
    2618:	aa020083 	orr	x3, x4, x2
	dsb();
    261c:	d5033f9f 	dsb	sy
	if (el == 1) {
    2620:	d2808001 	mov	x1, #0x400                 	// #1024
    2624:	f2a88181 	movk	x1, #0x440c, lsl #16
    2628:	f2d77fe1 	movk	x1, #0xbbff, lsl #32
    262c:	54000901 	b.ne	274c <mmu_early_enable+0x1a4>  // b.any
		asm volatile("msr ttbr0_el1, %0" : : "r" (table) : "memory");
    2630:	d5182000 	msr	ttbr0_el1, x0
		asm volatile("msr tcr_el1, %0" : : "r" (tcr) : "memory");
    2634:	d5182043 	msr	tcr_el1, x3
		asm volatile("msr mair_el1, %0" : : "r" (attr) : "memory");
    2638:	d518a201 	msr	mair_el1, x1
	isb();
    263c:	d5033fdf 	isb
	el = current_el();
	set_ttbr_tcr_mair(el, ttb, calc_tcr(el, BITS_PER_VA), MEMORY_ATTRIBUTES);
	if (el == 3)
		set_ttbr_tcr_mair(2, ttb, calc_tcr(2, BITS_PER_VA), MEMORY_ATTRIBUTES);

	memset((void *)ttb, 0, GRANULE_SIZE);
    2640:	d2820002 	mov	x2, #0x1000                	// #4096
    2644:	52800001 	mov	w1, #0x0                   	// #0
    2648:	9400048f 	bl	3884 <__memset>
	uint64_t *ttb = get_ttb();
    264c:	97fffeab 	bl	20f8 <get_ttb>
    2650:	aa0003f7 	mov	x23, x0
		early_remap_range(addr, L0_XLAT_SIZE, MAP_UNCACHED);
    2654:	52800002 	mov	w2, #0x0                   	// #0
    2658:	d2c01001 	mov	x1, #0x8000000000          	// #549755813888
    265c:	d2800000 	mov	x0, #0x0                   	// #0
    2660:	97ffffca 	bl	2588 <early_remap_range>
		split_block(ttb, 0, false);
    2664:	aa1703e0 	mov	x0, x23
    2668:	52800001 	mov	w1, #0x0                   	// #0
    266c:	97fffed5 	bl	21c0 <split_block.isra.0>
		early_remap_range(addr, L0_XLAT_SIZE, MAP_UNCACHED);
    2670:	52800002 	mov	w2, #0x0                   	// #0
    2674:	d2c01001 	mov	x1, #0x8000000000          	// #549755813888
    2678:	aa0103e0 	mov	x0, x1
    267c:	97ffffc3 	bl	2588 <early_remap_range>
		split_block(ttb, 0, false);
    2680:	910022e0 	add	x0, x23, #0x8
    2684:	52800001 	mov	w1, #0x0                   	// #0
    2688:	97fffece 	bl	21c0 <split_block.isra.0>
	 * Assume maximum BITS_PER_PA set to 40 bits.
	 * Set 1:1 mapping of VA->PA. So to cover the full 1TB range we need 2 tables.
	 */
	early_init_range(2);

	early_remap_range(membase, memsize, ARCH_MAP_CACHED_RWX);
    268c:	aa1603e1 	mov	x1, x22
    2690:	aa1503e0 	mov	x0, x21
    2694:	529fffa2 	mov	w2, #0xfffd                	// #65533
    2698:	97ffffbc 	bl	2588 <early_remap_range>
	/*
	 * map barebox area using pagewise mapping. We want to modify the XN/RO
	 * attributes later, but can't switch from sections to pages later when
	 * executing code from it
	 */
	early_remap_range(barebox_start, barebox_size,
    269c:	529fffa2 	mov	w2, #0xfffd                	// #65533
    26a0:	cb130281 	sub	x1, x20, x19
    26a4:	aa1303e0 	mov	x0, x19
    26a8:	72b00002 	movk	w2, #0x8000, lsl #16
    26ac:	97ffffb7 	bl	2588 <early_remap_range>
		     ARCH_MAP_CACHED_RWX | ARCH_MAP_FLAG_PAGEWISE);

	/* OP-TEE might be at location specified in OP-TEE header */
	optee_get_membase(&optee_membase);

	early_remap_range(optee_membase, OPTEE_SIZE, MAP_FAULT);
    26b0:	aa1403e0 	mov	x0, x20
    26b4:	52800042 	mov	w2, #0x2                   	// #2
    26b8:	d2800001 	mov	x1, #0x0                   	// #0
    26bc:	97ffffb3 	bl	2588 <early_remap_range>

	early_remap_range(PAGE_ALIGN_DOWN((uintptr_t)_stext), PAGE_ALIGN(_etext - _stext),
    26c0:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    26c4:	f9478400 	ldr	x0, [x0, #3848]
    26c8:	529fffa2 	mov	w2, #0xfffd                	// #65533
    26cc:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    26d0:	f9477021 	ldr	x1, [x1, #3808]
    26d4:	cb000021 	sub	x1, x1, x0
    26d8:	9274cc00 	and	x0, x0, #0xfffffffffffff000
    26dc:	913ffc21 	add	x1, x1, #0xfff
    26e0:	9274cc21 	and	x1, x1, #0xfffffffffffff000
    26e4:	97ffffa9 	bl	2588 <early_remap_range>
	isb();
    26e8:	d5033fdf 	isb
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    26ec:	d5384240 	mrs	x0, currentel
	return el >> 2;
    26f0:	53027c00 	lsr	w0, w0, #2
	if (el == 1)
    26f4:	7100041f 	cmp	w0, #0x1
    26f8:	540004e1 	b.ne	2794 <mmu_early_enable+0x1ec>  // b.any
		asm volatile("mrs %0, sctlr_el1" : "=r" (val) : : "cc");
    26fc:	d5381000 	mrs	x0, sctlr_el1
	set_cr(get_cr() | CR_M | CR_C | CR_I);
    2700:	528200a1 	mov	w1, #0x1005                	// #4101
    2704:	2a010000 	orr	w0, w0, w1
	asm volatile("mrs %0, CurrentEL" : "=r" (el) : : "cc");
    2708:	d5384241 	mrs	x1, currentel
	return el >> 2;
    270c:	53027c21 	lsr	w1, w1, #2
{
#ifdef CONFIG_CPU_64v8
	unsigned int el;

	el = current_el();
	if (el == 1)
    2710:	7100043f 	cmp	w1, #0x1
    2714:	540004c1 	b.ne	27ac <mmu_early_enable+0x204>  // b.any
		asm volatile("msr sctlr_el1, %0" : : "r" (val) : "cc");
    2718:	d5181000 	msr	sctlr_el1, x0
		asm volatile("msr sctlr_el3, %0" : : "r" (val) : "cc");
#else
	asm volatile("mcr p15, 0, %0, c1, c0, 0 @ set CR"
	  : : "r" (val) : "cc");
#endif
	isb();
    271c:	d5033fdf 	isb
			  ARCH_MAP_CACHED_RWX);

	mmu_enable();
}
    2720:	a94153f3 	ldp	x19, x20, [sp, #16]
    2724:	a9425bf5 	ldp	x21, x22, [sp, #32]
    2728:	f9401bf7 	ldr	x23, [sp, #48]
    272c:	a8c47bfd 	ldp	x29, x30, [sp], #64
    2730:	d65f03c0 	ret
	else if (el == 2)
    2734:	7100081f 	cmp	w0, #0x2
    2738:	54000061 	b.ne	2744 <mmu_early_enable+0x19c>  // b.any
		asm volatile("mrs %0, sctlr_el2" : "=r" (val) : : "cc");
    273c:	d53c1003 	mrs	x3, sctlr_el2
    2740:	17ffffa7 	b	25dc <mmu_early_enable+0x34>
		asm volatile("mrs %0, sctlr_el3" : "=r" (val) : : "cc");
    2744:	d53e1003 	mrs	x3, sctlr_el3
    2748:	17ffffa5 	b	25dc <mmu_early_enable+0x34>
	} else if (el == 2) {
    274c:	710008bf 	cmp	w5, #0x2
    2750:	540000a1 	b.ne	2764 <mmu_early_enable+0x1bc>  // b.any
		asm volatile("msr ttbr0_el2, %0" : : "r" (table) : "memory");
    2754:	d51c2000 	msr	ttbr0_el2, x0
		asm volatile("msr tcr_el2, %0" : : "r" (tcr) : "memory");
    2758:	d51c2043 	msr	tcr_el2, x3
		asm volatile("msr mair_el2, %0" : : "r" (attr) : "memory");
    275c:	d51ca201 	msr	mair_el2, x1
    2760:	17ffffb7 	b	263c <mmu_early_enable+0x94>
	} else if (el == 3) {
    2764:	71000cbf 	cmp	w5, #0x3
    2768:	54000141 	b.ne	2790 <mmu_early_enable+0x1e8>  // b.any
		asm volatile("msr ttbr0_el3, %0" : : "r" (table) : "memory");
    276c:	d51e2000 	msr	ttbr0_el3, x0
		asm volatile("msr tcr_el3, %0" : : "r" (tcr) : "memory");
    2770:	d51e2043 	msr	tcr_el3, x3
		asm volatile("msr mair_el3, %0" : : "r" (attr) : "memory");
    2774:	d51ea201 	msr	mair_el3, x1
	isb();
    2778:	d5033fdf 	isb
	dsb();
    277c:	d5033f9f 	dsb	sy
		asm volatile("msr ttbr0_el2, %0" : : "r" (table) : "memory");
    2780:	d51c2000 	msr	ttbr0_el2, x0
		asm volatile("msr tcr_el2, %0" : : "r" (tcr) : "memory");
    2784:	91408042 	add	x2, x2, #0x20, lsl #12
    2788:	d51c2042 	msr	tcr_el2, x2
		asm volatile("msr mair_el2, %0" : : "r" (attr) : "memory");
    278c:	17fffff4 	b	275c <mmu_early_enable+0x1b4>
		hang();
    2790:	940003d0 	bl	36d0 <hang>
	else if (el == 2)
    2794:	7100081f 	cmp	w0, #0x2
    2798:	54000061 	b.ne	27a4 <mmu_early_enable+0x1fc>  // b.any
		asm volatile("mrs %0, sctlr_el2" : "=r" (val) : : "cc");
    279c:	d53c1000 	mrs	x0, sctlr_el2
    27a0:	17ffffd8 	b	2700 <mmu_early_enable+0x158>
		asm volatile("mrs %0, sctlr_el3" : "=r" (val) : : "cc");
    27a4:	d53e1000 	mrs	x0, sctlr_el3
    27a8:	17ffffd6 	b	2700 <mmu_early_enable+0x158>
	else if (el == 2)
    27ac:	7100083f 	cmp	w1, #0x2
    27b0:	54000061 	b.ne	27bc <mmu_early_enable+0x214>  // b.any
		asm volatile("msr sctlr_el2, %0" : : "r" (val) : "cc");
    27b4:	d51c1000 	msr	sctlr_el2, x0
    27b8:	17ffffd9 	b	271c <mmu_early_enable+0x174>
		asm volatile("msr sctlr_el3, %0" : : "r" (val) : "cc");
    27bc:	d51e1000 	msr	sctlr_el3, x0
    27c0:	17ffffd7 	b	271c <mmu_early_enable+0x174>

00000000000027c4 <setup_c>:
    27c4:	aa1e03ef 	mov	x15, x30
    27c8:	d0000000 	adrp	x0, 4000 <__rel_dyn_start+0xb8>
    27cc:	91014000 	add	x0, x0, #0x50
    27d0:	d2800001 	mov	x1, #0x0                   	// #0
    27d4:	d0000002 	adrp	x2, 4000 <__rel_dyn_start+0xb8>
    27d8:	9101a042 	add	x2, x2, #0x68
    27dc:	cb000042 	sub	x2, x2, x0
    27e0:	94000429 	bl	3884 <__memset>
    27e4:	aa0f03fe 	mov	x30, x15
    27e8:	d65f03c0 	ret

00000000000027ec <relocate_to_adr_full>:
    27ec:	90000962 	adrp	x2, 12e000 <__pecoff_data_rawsize+0x3798>
    27f0:	9116a042 	add	x2, x2, #0x5a8
    27f4:	14000004 	b	2804 <relocate_to_adr+0xc>

00000000000027f8 <relocate_to_adr>:
    27f8:	d0000002 	adrp	x2, 4000 <__rel_dyn_start+0xb8>
    27fc:	91014042 	add	x2, x2, #0x50
    2800:	14000001 	b	2804 <relocate_to_adr+0xc>
    2804:	a9bf53f3 	stp	x19, x20, [sp, #-16]!
    2808:	a9bf5bf5 	stp	x21, x22, [sp, #-16]!
    280c:	aa1e03f3 	mov	x19, x30
    2810:	aa0003f5 	mov	x21, x0
    2814:	d0ffffe1 	adrp	x1, 0 <start_dt_2nd>
    2818:	91000021 	add	x1, x1, #0x0
    281c:	aa0103f4 	mov	x20, x1
    2820:	eb15003f 	cmp	x1, x21
    2824:	54000180 	b.eq	2854 <relocate_to_adr+0x5c>  // b.none
    2828:	cb010042 	sub	x2, x2, x1
    282c:	aa1503e0 	mov	x0, x21
    2830:	cb010273 	sub	x19, x19, x1
    2834:	8b000273 	add	x19, x19, x0
    2838:	940003bb 	bl	3724 <__memcpy>
    283c:	97fffd5f 	bl	1db8 <sync_caches_for_execution>
    2840:	90000000 	adrp	x0, 2000 <relocate_to_current_adr+0x1fc>
    2844:	91215000 	add	x0, x0, #0x854
    2848:	cb140000 	sub	x0, x0, x20
    284c:	8b150000 	add	x0, x0, x21
    2850:	d61f0000 	br	x0
    2854:	97fffd6c 	bl	1e04 <relocate_to_current_adr>
    2858:	aa1303fe 	mov	x30, x19
    285c:	a8c15bf5 	ldp	x21, x22, [sp], #16
    2860:	a8c153f3 	ldp	x19, x20, [sp], #16
    2864:	d65f03c0 	ret

0000000000002868 <barebox_pbl_start>:
extern unsigned char input_data[];
extern unsigned char input_data_end[];

void __noreturn barebox_pbl_start(unsigned long membase, unsigned long memsize,
				  void *boarddata)
{
    2868:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    286c:	910003fd 	mov	x29, sp
    2870:	a90153f3 	stp	x19, x20, [sp, #16]
    2874:	d1404033 	sub	x19, x1, #0x10, lsl #12
    2878:	a9025bf5 	stp	x21, x22, [sp, #32]
    287c:	aa0003f5 	mov	x21, x0
    2880:	aa0103f6 	mov	x22, x1
    2884:	a90363f7 	stp	x23, x24, [sp, #48]
    2888:	f90023f9 	str	x25, [sp, #64]
    288c:	aa0203f9 	mov	x25, x2
                "mov    %0, pc\n"
                : "=r" (pc)
                :
                : "memory");
#else
	__asm__ __volatile__(
    2890:	10000000 	adr	x0, 2890 <barebox_pbl_start+0x28>
	void *pg_start, *pg_end;
	unsigned long pc = get_pc();
	void *handoff_data;

	/* piggy data is not relocated, so determine the bounds now */
	pg_start = runtime_address(input_data);
    2894:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    2898:	f9477821 	ldr	x1, [x1, #3824]
    289c:	f9002be1 	str	x1, [sp, #80]
    28a0:	f9402bf4 	ldr	x20, [sp, #80]
    28a4:	d0ffffe1 	adrp	x1, 0 <start_dt_2nd>
    28a8:	91000021 	add	x1, x1, #0x0
	return text - (unsigned long)_text;
    28ac:	b0000002 	adrp	x2, 3000 <lz4_decompress+0x324>
    28b0:	f9477c42 	ldr	x2, [x2, #3832]
    28b4:	8b010294 	add	x20, x20, x1
	pg_end = runtime_address(input_data_end);
    28b8:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    28bc:	f9477421 	ldr	x1, [x1, #3816]
    28c0:	f9002fe1 	str	x1, [sp, #88]
	pg_start = runtime_address(input_data);
    28c4:	cb020294 	sub	x20, x20, x2
	pg_end = runtime_address(input_data_end);
    28c8:	f9402fe1 	ldr	x1, [sp, #88]
	__asm__ __volatile__(
    28cc:	d0ffffe3 	adrp	x3, 0 <start_dt_2nd>
    28d0:	91000063 	add	x3, x3, #0x0
    28d4:	8b030021 	add	x1, x1, x3
    28d8:	cb020038 	sub	x24, x1, x2
	/*
	 * If we run from inside the memory just relocate the binary
	 * to the current address. Otherwise it may be a readonly location.
	 * Copy and relocate to the start of the memory in this case.
	 */
	if (pc > membase && pc - membase < memsize)
    28dc:	eb0002bf 	cmp	x21, x0
    28e0:	54000682 	b.cs	29b0 <barebox_pbl_start+0x148>  // b.hs, b.nlast
    28e4:	cb150000 	sub	x0, x0, x21
    28e8:	eb16001f 	cmp	x0, x22
    28ec:	54000622 	b.cs	29b0 <barebox_pbl_start+0x148>  // b.hs, b.nlast
		relocate_to_current_adr();
    28f0:	97fffd45 	bl	1e04 <relocate_to_current_adr>
	else
		relocate_to_adr(membase);

	pg_len = pg_end - pg_start;
	uncompressed_len = get_unaligned((const u32 *)(pg_start + pg_len - 4));
    28f4:	4b140301 	sub	w1, w24, w20
	pg_len = pg_end - pg_start;
    28f8:	cb140317 	sub	x23, x24, x20
	uncompressed_len = get_unaligned((const u32 *)(pg_start + pg_len - 4));
    28fc:	8b010281 	add	x1, x20, x1
    2900:	385fc020 	ldurb	w0, [x1, #-4]
    2904:	385fd022 	ldurb	w2, [x1, #-3]
    2908:	385ff038 	ldurb	w24, [x1, #-1]
    290c:	aa022002 	orr	x2, x0, x2, lsl #8
    2910:	385fe020 	ldurb	w0, [x1, #-2]
    2914:	aa004040 	orr	x0, x2, x0, lsl #16
    2918:	aa186018 	orr	x24, x0, x24, lsl #24

	setup_c();
    291c:	97ffffaa 	bl	27c4 <setup_c>
	pr_debug("memory at 0x%08lx, size 0x%08lx\n", membase, memsize);

	arm_pbl_init_exceptions();

	/* Add handoff data now, so arm_mem_barebox_image takes it into account */
	if (boarddata)
    2920:	b4000079 	cbz	x25, 292c <barebox_pbl_start+0xc4>
		handoff_data_add_dt(boarddata);
    2924:	aa1903e0 	mov	x0, x25
    2928:	94000329 	bl	35cc <handoff_data_add_dt>
	return arm_mem_scratch(endmem) - STACK_SIZE;
    292c:	8b1302b3 	add	x19, x21, x19

	barebox_base = arm_mem_barebox_image(membase, endmem,
    2930:	2a1803f8 	mov	w24, w24
	return ALIGN_DOWN(endmem, PAGE_SIZE) - PAGE_SIZE;
    2934:	9274ce73 	and	x19, x19, #0xfffffffffffff000
static inline unsigned long arm_mem_barebox_image(unsigned long membase,
						  unsigned long endmem,
						  unsigned long uncompressed_len,
						  const struct handoff_data *handoff_data)
{
	unsigned long size = uncompressed_len + MAX_BSS_SIZE + __handoff_data_size(handoff_data);
    2938:	d2800000 	mov	x0, #0x0                   	// #0
	return ALIGN_DOWN(endmem, PAGE_SIZE) - PAGE_SIZE;
    293c:	d1400673 	sub	x19, x19, #0x1, lsl #12
	unsigned long size = uncompressed_len + MAX_BSS_SIZE + __handoff_data_size(handoff_data);
    2940:	940002d2 	bl	3488 <__handoff_data_size>
	endmem = ALIGN_DOWN(endmem, ARM_EARLY_PAGETABLE_SIZE) - ARM_EARLY_PAGETABLE_SIZE;
    2944:	926eb673 	and	x19, x19, #0xfffffffffffc0000

	endmem = arm_mem_ramoops(endmem);

	return ALIGN_DOWN(endmem - size, SZ_1M);
    2948:	8b000300 	add	x0, x24, x0
    294c:	d1450273 	sub	x19, x19, #0x140, lsl #12
					     uncompressed_len, NULL);

	handoff_data = (void *)barebox_base + uncompressed_len + MAX_BSS_SIZE;
    2950:	91440318 	add	x24, x24, #0x100, lsl #12
    2954:	cb000273 	sub	x19, x19, x0

	free_mem_ptr = barebox_base - ARM_MEM_EARLY_MALLOC_SIZE;
    2958:	d0000000 	adrp	x0, 4000 <__rel_dyn_start+0xb8>
    295c:	926cae73 	and	x19, x19, #0xfffffffffff00000
    2960:	d1408261 	sub	x1, x19, #0x20, lsl #12
    2964:	f9003001 	str	x1, [x0, #96]
	free_mem_end_ptr = barebox_base;
    2968:	d0000000 	adrp	x0, 4000 <__rel_dyn_start+0xb8>

#ifdef DEBUG
	print_pbl_mem_layout(membase, endmem, barebox_base);
#endif
	if (IS_ENABLED(CONFIG_MMU))
		mmu_early_enable(membase, memsize, barebox_base);
    296c:	aa1303e2 	mov	x2, x19
    2970:	aa1603e1 	mov	x1, x22
	handoff_data = (void *)barebox_base + uncompressed_len + MAX_BSS_SIZE;
    2974:	8b130318 	add	x24, x24, x19
	free_mem_end_ptr = barebox_base;
    2978:	f9002c13 	str	x19, [x0, #88]
		mmu_early_enable(membase, memsize, barebox_base);
    297c:	aa1503e0 	mov	x0, x21
    2980:	97ffff0a 	bl	25a8 <mmu_early_enable>
		set_cr(get_cr() | CR_C);

	pr_debug("uncompressing barebox binary at 0x%p (size 0x%08x) to 0x%08lx (uncompressed size: 0x%08x)\n",
			pg_start, pg_len, barebox_base, uncompressed_len);

	pbl_barebox_uncompress((void*)barebox_base, pg_start, pg_len);
    2984:	2a1703e2 	mov	w2, w23
    2988:	aa1403e1 	mov	x1, x20
    298c:	aa1303e0 	mov	x0, x19
    2990:	940001ef 	bl	314c <pbl_barebox_uncompress>

	handoff_data_move(handoff_data);
    2994:	aa1803e0 	mov	x0, x24
    2998:	940002dd 	bl	350c <handoff_data_move>

	sync_caches_for_execution();
    299c:	97fffd07 	bl	1db8 <sync_caches_for_execution>
	pr_debug("jumping to uncompressed image at 0x%p\n", barebox);

	if (IS_ENABLED(CONFIG_CPU_V7) && boot_cpu_mode() == HYP_MODE)
		armv7_switch_to_hyp();

	barebox(membase, memsize, handoff_data);
    29a0:	aa1803e2 	mov	x2, x24
    29a4:	aa1603e1 	mov	x1, x22
    29a8:	aa1503e0 	mov	x0, x21
    29ac:	d63f0260 	blr	x19
		relocate_to_adr(membase);
    29b0:	aa1503e0 	mov	x0, x21
    29b4:	97ffff91 	bl	27f8 <relocate_to_adr>
    29b8:	17ffffcf 	b	28f4 <barebox_pbl_start+0x8c>

00000000000029bc <console_putc>:
	putc(ctx, c);
}

void console_putc(unsigned int ch, char c)
{
	if (putc_offset)
    29bc:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
{
    29c0:	12001c21 	and	w1, w1, #0xff
	if (putc_offset)
    29c4:	f946a800 	ldr	x0, [x0, #3408]
    29c8:	b5000160 	cbnz	x0, 29f4 <console_putc+0x38>
    29cc:	d2860180 	mov	x0, #0x300c                	// #12300
    29d0:	f2bff000 	movk	x0, #0xff80, lsl #16
    29d4:	b9400002 	ldr	w2, [x0]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    29d8:	37afffe2 	tbnz	w2, #21, 29d4 <console_putc+0x18>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    29dc:	d2860002 	mov	x2, #0x3000                	// #12288
    29e0:	f2bff002 	movk	x2, #0xff80, lsl #16
    29e4:	b9000041 	str	w1, [x2]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    29e8:	b9400001 	ldr	w1, [x0]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    29ec:	36b7ffe1 	tbz	w1, #22, 29e8 <console_putc+0x2c>
    29f0:	d65f03c0 	ret
	void (*putc)(void *, int) = (void *)_text + putc_offset;
    29f4:	b0000002 	adrp	x2, 3000 <lz4_decompress+0x324>
    29f8:	f9477c42 	ldr	x2, [x2, #3832]
{
    29fc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	void (*putc)(void *, int) = (void *)_text + putc_offset;
    2a00:	8b020002 	add	x2, x0, x2
	putc(ctx, c);
    2a04:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
{
    2a08:	910003fd 	mov	x29, sp
	putc(ctx, c);
    2a0c:	f946a400 	ldr	x0, [x0, #3400]
    2a10:	d63f0040 	blr	x2
		__putc(putc_ctx, c);
	else
		putc_ll(c);
}
    2a14:	a8c17bfd 	ldp	x29, x30, [sp], #16
    2a18:	d65f03c0 	ret

0000000000002a1c <console_puts>:

int console_puts(unsigned int ch, const char *str)
{
    2a1c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    2a20:	910003fd 	mov	x29, sp
    2a24:	a90153f3 	stp	x19, x20, [sp, #16]
    2a28:	aa0103f4 	mov	x20, x1
	int n = 0;

	while (*str) {
    2a2c:	d2800013 	mov	x19, #0x0                   	// #0
{
    2a30:	f90013f5 	str	x21, [sp, #32]
    2a34:	2a0003f5 	mov	w21, w0
	while (*str) {
    2a38:	38736a80 	ldrb	w0, [x20, x19]
    2a3c:	350000c0 	cbnz	w0, 2a54 <console_puts+0x38>
		str++;
		n++;
	}

	return n;
}
    2a40:	f94013f5 	ldr	x21, [sp, #32]
    2a44:	2a1303e0 	mov	w0, w19
    2a48:	a94153f3 	ldp	x19, x20, [sp, #16]
    2a4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    2a50:	d65f03c0 	ret
		if (*str == '\n')
    2a54:	7100281f 	cmp	w0, #0xa
    2a58:	54000081 	b.ne	2a68 <console_puts+0x4c>  // b.any
			console_putc(ch, '\r');
    2a5c:	2a1503e0 	mov	w0, w21
    2a60:	528001a1 	mov	w1, #0xd                   	// #13
    2a64:	97ffffd6 	bl	29bc <console_putc>
		console_putc(ch, *str);
    2a68:	38736a81 	ldrb	w1, [x20, x19]
    2a6c:	2a1503e0 	mov	w0, w21
    2a70:	91000673 	add	x19, x19, #0x1
    2a74:	97ffffd2 	bl	29bc <console_putc>
		n++;
    2a78:	17fffff0 	b	2a38 <console_puts+0x1c>

0000000000002a7c <printf>:

int printf(const char *fmt, ...)
{
    2a7c:	d11343ff 	sub	sp, sp, #0x4d0
    2a80:	911263e8 	add	x8, sp, #0x498
    2a84:	a9007bfd 	stp	x29, x30, [sp]
    2a88:	910003fd 	mov	x29, sp
    2a8c:	a90153f3 	stp	x19, x20, [sp, #16]
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];
    2a90:	9101c3f3 	add	x19, sp, #0x70
{
    2a94:	aa0003f4 	mov	x20, x0
    2a98:	f90013f5 	str	x21, [sp, #32]
	char printbuffer[CFG_PBSIZE];
    2a9c:	aa1303e0 	mov	x0, x19
{
    2aa0:	a9000901 	stp	x1, x2, [x8]
	char printbuffer[CFG_PBSIZE];
    2aa4:	d2808355 	mov	x21, #0x41a                 	// #1050
    2aa8:	52800001 	mov	w1, #0x0                   	// #0
{
    2aac:	a9011103 	stp	x3, x4, [x8, #16]
	char printbuffer[CFG_PBSIZE];
    2ab0:	aa1503e2 	mov	x2, x21
{
    2ab4:	f9025fe5 	str	x5, [sp, #1208]
    2ab8:	f90263e6 	str	x6, [sp, #1216]
    2abc:	f90267e7 	str	x7, [sp, #1224]
	char printbuffer[CFG_PBSIZE];
    2ac0:	94000371 	bl	3884 <__memset>

	va_start(args, fmt);
    2ac4:	911343e0 	add	x0, sp, #0x4d0
    2ac8:	a90503e0 	stp	x0, x0, [sp, #80]
    2acc:	911243e0 	add	x0, sp, #0x490
    2ad0:	f90033e0 	str	x0, [sp, #96]
    2ad4:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    2ad8:	b9006be0 	str	w0, [sp, #104]
	i = vsnprintf(printbuffer, sizeof(printbuffer), fmt, args);
    2adc:	9100c3e3 	add	x3, sp, #0x30
	va_start(args, fmt);
    2ae0:	b9006fff 	str	wzr, [sp, #108]
	i = vsnprintf(printbuffer, sizeof(printbuffer), fmt, args);
    2ae4:	aa1403e2 	mov	x2, x20
    2ae8:	a94507e0 	ldp	x0, x1, [sp, #80]
    2aec:	a90307e0 	stp	x0, x1, [sp, #48]
    2af0:	a94607e0 	ldp	x0, x1, [sp, #96]
    2af4:	a90407e0 	stp	x0, x1, [sp, #64]
    2af8:	aa1503e1 	mov	x1, x21
    2afc:	aa1303e0 	mov	x0, x19
    2b00:	97fffa37 	bl	13dc <vsnprintf>
    2b04:	2a0003f4 	mov	w20, w0
	va_end(args);

	console_puts(CONSOLE_STDOUT, printbuffer);
    2b08:	aa1303e1 	mov	x1, x19
    2b0c:	52800040 	mov	w0, #0x2                   	// #2
    2b10:	97ffffc3 	bl	2a1c <console_puts>

	return i;
}
    2b14:	a9407bfd 	ldp	x29, x30, [sp]
    2b18:	2a1403e0 	mov	w0, w20
    2b1c:	a94153f3 	ldp	x19, x20, [sp, #16]
    2b20:	f94013f5 	ldr	x21, [sp, #32]
    2b24:	911343ff 	add	sp, sp, #0x4d0
    2b28:	d65f03c0 	ret

0000000000002b2c <pr_print>:

int pr_print(int level, const char *fmt, ...)
{
    2b2c:	d11303ff 	sub	sp, sp, #0x4c0
    2b30:	911243e8 	add	x8, sp, #0x490
    2b34:	a9007bfd 	stp	x29, x30, [sp]
    2b38:	910003fd 	mov	x29, sp
    2b3c:	a90153f3 	stp	x19, x20, [sp, #16]
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];
    2b40:	9101c3f3 	add	x19, sp, #0x70
{
    2b44:	aa0103f4 	mov	x20, x1
    2b48:	f90013f5 	str	x21, [sp, #32]
	char printbuffer[CFG_PBSIZE];
    2b4c:	aa1303e0 	mov	x0, x19
{
    2b50:	a9000d02 	stp	x2, x3, [x8]
	char printbuffer[CFG_PBSIZE];
    2b54:	d2808355 	mov	x21, #0x41a                 	// #1050
    2b58:	52800001 	mov	w1, #0x0                   	// #0
{
    2b5c:	a9011504 	stp	x4, x5, [x8, #16]
	char printbuffer[CFG_PBSIZE];
    2b60:	aa1503e2 	mov	x2, x21
{
    2b64:	f9025be6 	str	x6, [sp, #1200]
    2b68:	f9025fe7 	str	x7, [sp, #1208]
	char printbuffer[CFG_PBSIZE];
    2b6c:	94000346 	bl	3884 <__memset>

	va_start(args, fmt);
    2b70:	911303e0 	add	x0, sp, #0x4c0
    2b74:	a90503e0 	stp	x0, x0, [sp, #80]
    2b78:	911243e0 	add	x0, sp, #0x490
    2b7c:	f90033e0 	str	x0, [sp, #96]
    2b80:	128005e0 	mov	w0, #0xffffffd0            	// #-48
    2b84:	b9006be0 	str	w0, [sp, #104]
	i = vsnprintf(printbuffer, sizeof(printbuffer), fmt, args);
    2b88:	9100c3e3 	add	x3, sp, #0x30
	va_start(args, fmt);
    2b8c:	b9006fff 	str	wzr, [sp, #108]
	i = vsnprintf(printbuffer, sizeof(printbuffer), fmt, args);
    2b90:	aa1403e2 	mov	x2, x20
    2b94:	a94507e0 	ldp	x0, x1, [sp, #80]
    2b98:	a90307e0 	stp	x0, x1, [sp, #48]
    2b9c:	a94607e0 	ldp	x0, x1, [sp, #96]
    2ba0:	a90407e0 	stp	x0, x1, [sp, #64]
    2ba4:	aa1503e1 	mov	x1, x21
    2ba8:	aa1303e0 	mov	x0, x19
    2bac:	97fffa0c 	bl	13dc <vsnprintf>
    2bb0:	2a0003f4 	mov	w20, w0
	va_end(args);

	console_puts(CONSOLE_STDERR, printbuffer);
    2bb4:	aa1303e1 	mov	x1, x19
    2bb8:	52800080 	mov	w0, #0x4                   	// #4
    2bbc:	97ffff98 	bl	2a1c <console_puts>

	return i;
}
    2bc0:	a9407bfd 	ldp	x29, x30, [sp]
    2bc4:	2a1403e0 	mov	w0, w20
    2bc8:	a94153f3 	ldp	x19, x20, [sp, #16]
    2bcc:	f94013f5 	ldr	x21, [sp, #32]
    2bd0:	911303ff 	add	sp, sp, #0x4c0
    2bd4:	d65f03c0 	ret

0000000000002bd8 <errorfn>:
    2bd8:	d2860182 	mov	x2, #0x300c                	// #12300
 * link address which often is not the case during early startup. If in doubt
 * don't use it.
 */
static inline void puts_ll(const char * str)
{
	while (*str) {
    2bdc:	b0000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    2be0:	f2bff002 	movk	x2, #0xff80, lsl #16
    2be4:	91268821 	add	x1, x1, #0x9a2
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2be8:	d1003044 	sub	x4, x2, #0xc
    2bec:	528001a5 	mov	w5, #0xd                   	// #13
    2bf0:	39400023 	ldrb	w3, [x1]
    2bf4:	35000203 	cbnz	w3, 2c34 <errorfn+0x5c>
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2bf8:	d2860181 	mov	x1, #0x300c                	// #12300
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2bfc:	528001a4 	mov	w4, #0xd                   	// #13
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c00:	f2bff001 	movk	x1, #0xff80, lsl #16
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2c04:	d1003023 	sub	x3, x1, #0xc
    2c08:	39400002 	ldrb	w2, [x0]
    2c0c:	35000302 	cbnz	w2, 2c6c <errorfn+0x94>
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c10:	d2860181 	mov	x1, #0x300c                	// #12300
    2c14:	b0000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    2c18:	f2bff001 	movk	x1, #0xff80, lsl #16
    2c1c:	9126a800 	add	x0, x0, #0x9aa
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2c20:	d1003023 	sub	x3, x1, #0xc
    2c24:	528001a4 	mov	w4, #0xd                   	// #13
    2c28:	39400002 	ldrb	w2, [x0]
    2c2c:	350003c2 	cbnz	w2, 2ca4 <errorfn+0xcc>
static void noinline errorfn(char *error)
{
	puts_ll("ERROR: ");
	puts_ll(error);
	puts_ll("\nHANG\n");
	while (1);
    2c30:	14000000 	b	2c30 <errorfn+0x58>
		if (*str == '\n')
    2c34:	7100287f 	cmp	w3, #0xa
    2c38:	540000c1 	b.ne	2c50 <errorfn+0x78>  // b.any
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c3c:	b9400046 	ldr	w6, [x2]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2c40:	37afffe6 	tbnz	w6, #21, 2c3c <errorfn+0x64>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2c44:	b9000085 	str	w5, [x4]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c48:	b9400046 	ldr	w6, [x2]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2c4c:	36b7ffe6 	tbz	w6, #22, 2c48 <errorfn+0x70>
    2c50:	b9400046 	ldr	w6, [x2]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2c54:	37afffe6 	tbnz	w6, #21, 2c50 <errorfn+0x78>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2c58:	b9000083 	str	w3, [x4]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c5c:	b9400043 	ldr	w3, [x2]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2c60:	36b7ffe3 	tbz	w3, #22, 2c5c <errorfn+0x84>
			putc_ll('\r');

		putc_ll(*str);
		str++;
    2c64:	91000421 	add	x1, x1, #0x1
    2c68:	17ffffe2 	b	2bf0 <errorfn+0x18>
		if (*str == '\n')
    2c6c:	7100285f 	cmp	w2, #0xa
    2c70:	540000c1 	b.ne	2c88 <errorfn+0xb0>  // b.any
    2c74:	b9400025 	ldr	w5, [x1]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2c78:	37afffe5 	tbnz	w5, #21, 2c74 <errorfn+0x9c>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2c7c:	b9000064 	str	w4, [x3]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c80:	b9400025 	ldr	w5, [x1]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2c84:	36b7ffe5 	tbz	w5, #22, 2c80 <errorfn+0xa8>
    2c88:	b9400025 	ldr	w5, [x1]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2c8c:	37afffe5 	tbnz	w5, #21, 2c88 <errorfn+0xb0>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2c90:	b9000062 	str	w2, [x3]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2c94:	b9400022 	ldr	w2, [x1]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2c98:	36b7ffe2 	tbz	w2, #22, 2c94 <errorfn+0xbc>
		str++;
    2c9c:	91000400 	add	x0, x0, #0x1
    2ca0:	17ffffda 	b	2c08 <errorfn+0x30>
		if (*str == '\n')
    2ca4:	7100285f 	cmp	w2, #0xa
    2ca8:	540000c1 	b.ne	2cc0 <errorfn+0xe8>  // b.any
    2cac:	b9400025 	ldr	w5, [x1]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2cb0:	37afffe5 	tbnz	w5, #21, 2cac <errorfn+0xd4>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2cb4:	b9000064 	str	w4, [x3]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2cb8:	b9400025 	ldr	w5, [x1]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2cbc:	36b7ffe5 	tbz	w5, #22, 2cb8 <errorfn+0xe0>
    2cc0:	b9400025 	ldr	w5, [x1]
	while (readl(base + AML_UART_STATUS) & AML_UART_TX_FULL)
    2cc4:	37afffe5 	tbnz	w5, #21, 2cc0 <errorfn+0xe8>
	asm volatile("str %w0, %1" : : "rZ" (val), "Qo" (*ptr));
    2cc8:	b9000062 	str	w2, [x3]
	asm volatile("ldr %w0, [%1]" : "=r" (val) : "r" (addr));
    2ccc:	b9400022 	ldr	w2, [x1]
	while (!(readl(base + AML_UART_STATUS) & AML_UART_TX_EMPTY))
    2cd0:	36b7ffe2 	tbz	w2, #22, 2ccc <errorfn+0xf4>
		str++;
    2cd4:	91000400 	add	x0, x0, #0x1
    2cd8:	17ffffd4 	b	2c28 <errorfn+0x50>

0000000000002cdc <lz4_decompress>:
	return (int) (-(((char *) ip) - source));
}

int lz4_decompress(const char *src, size_t *src_len, char *dest,
		size_t actual_dest_len)
{
    2cdc:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
    2ce0:	910003fd 	mov	x29, sp
    2ce4:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
    2ce8:	b0000013 	adrp	x19, 3000 <lz4_decompress+0x324>
    2cec:	912f8273 	add	x19, x19, #0xbe0
{
    2cf0:	a90363f7 	stp	x23, x24, [sp, #48]
	size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
    2cf4:	910143f8 	add	x24, sp, #0x50
{
    2cf8:	aa0003f4 	mov	x20, x0
    2cfc:	aa0203f7 	mov	x23, x2
	size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
    2d00:	aa1803e0 	mov	x0, x24
{
    2d04:	a9025bf5 	stp	x21, x22, [sp, #32]
	BYTE * const oend = op + osize;
    2d08:	8b23c056 	add	x22, x2, w3, sxtw
{
    2d0c:	aa0103f5 	mov	x21, x1
	size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
    2d10:	d2800802 	mov	x2, #0x40                  	// #64
    2d14:	aa1303e1 	mov	x1, x19
{
    2d18:	f90023f9 	str	x25, [sp, #64]
	size_t dec32table[] = {0, 3, 2, 3, 0, 0, 0, 0};
    2d1c:	94000282 	bl	3724 <__memcpy>
	size_t dec64table[] = {0, 0, 0, -1, 0, 1, 2, 3};
    2d20:	910243e3 	add	x3, sp, #0x90
    2d24:	d2800802 	mov	x2, #0x40                  	// #64
    2d28:	aa0303e0 	mov	x0, x3
    2d2c:	8b020261 	add	x1, x19, x2
    2d30:	9400027d 	bl	3724 <__memcpy>
    2d34:	aa0003e3 	mov	x3, x0
	const BYTE *ip = (const BYTE *) source;
    2d38:	aa1403e6 	mov	x6, x20
	BYTE *op = (BYTE *) dest;
    2d3c:	aa1703e0 	mov	x0, x23
		if (unlikely(cpy > oend - COPYLENGTH)) {
    2d40:	d10022c2 	sub	x2, x22, #0x8
		token = *ip++;
    2d44:	aa0603f9 	mov	x25, x6
    2d48:	38401721 	ldrb	w1, [x25], #1
		length = (token >> ML_BITS);
    2d4c:	53047c24 	lsr	w4, w1, #4
    2d50:	d3441c33 	ubfx	x19, x1, #4, #4
		if (length == RUN_MASK) {
    2d54:	71003c9f 	cmp	w4, #0xf
    2d58:	54000101 	b.ne	2d78 <lz4_decompress+0x9c>  // b.any
			len = *ip++;
    2d5c:	394004c4 	ldrb	w4, [x6, #1]
    2d60:	910008d9 	add	x25, x6, #0x2
		length = (token >> ML_BITS);
    2d64:	d28001f3 	mov	x19, #0xf                   	// #15
			for (; len == 255; length += 255)
    2d68:	f103fc9f 	cmp	x4, #0xff
    2d6c:	540002a0 	b.eq	2dc0 <lz4_decompress+0xe4>  // b.none
			if (unlikely(length > (size_t)(length + len)))
    2d70:	ab040273 	adds	x19, x19, x4
    2d74:	54000182 	b.cs	2da4 <lz4_decompress+0xc8>  // b.hs, b.nlast
		cpy = op + length;
    2d78:	8b130004 	add	x4, x0, x19
		if (unlikely(cpy > oend - COPYLENGTH)) {
    2d7c:	eb02009f 	cmp	x4, x2
    2d80:	54000269 	b.ls	2dcc <lz4_decompress+0xf0>  // b.plast
			if (cpy != oend)
    2d84:	eb0402df 	cmp	x22, x4
    2d88:	540000e1 	b.ne	2da4 <lz4_decompress+0xc8>  // b.any
			memcpy(op, ip, length);
    2d8c:	aa1303e2 	mov	x2, x19
			ip += length;
    2d90:	8b130333 	add	x19, x25, x19
			memcpy(op, ip, length);
    2d94:	aa1903e1 	mov	x1, x25
	return (int) (((char *)ip) - source);
    2d98:	cb140273 	sub	x19, x19, x20
			memcpy(op, ip, length);
    2d9c:	94000262 	bl	3724 <__memcpy>
	int ret = -1;
	int input_len = 0;

	input_len = lz4_uncompress(src, dest, actual_dest_len);
	if (input_len < 0)
    2da0:	36f81cf3 	tbz	w19, #31, 313c <lz4_decompress+0x460>
		goto exit_0;
	*src_len = input_len;

	return 0;
exit_0:
	return ret;
    2da4:	12800000 	mov	w0, #0xffffffff            	// #-1
}
    2da8:	a94153f3 	ldp	x19, x20, [sp, #16]
    2dac:	a9425bf5 	ldp	x21, x22, [sp, #32]
    2db0:	a94363f7 	ldp	x23, x24, [sp, #48]
    2db4:	f94023f9 	ldr	x25, [sp, #64]
    2db8:	a8cd7bfd 	ldp	x29, x30, [sp], #208
    2dbc:	d65f03c0 	ret
				len = *ip++;
    2dc0:	38401724 	ldrb	w4, [x25], #1
			for (; len == 255; length += 255)
    2dc4:	9103fe73 	add	x19, x19, #0xff
    2dc8:	17ffffe8 	b	2d68 <lz4_decompress+0x8c>
    2dcc:	aa1903e5 	mov	x5, x25
	return p[0] | p[1] << 8 | p[2] << 16 | p[3] << 24;
}

static inline u64 __get_unaligned_le64(const u8 *p)
{
	return (u64)__get_unaligned_le32(p + 4) << 32 |
    2dd0:	394000a7 	ldrb	w7, [x5]
		LZ4_WILDCOPY(ip, op, cpy);
    2dd4:	91002000 	add	x0, x0, #0x8
    2dd8:	394004a6 	ldrb	w6, [x5, #1]
    2ddc:	910020a5 	add	x5, x5, #0x8
    2de0:	aa0620e6 	orr	x6, x7, x6, lsl #8
    2de4:	385fa0a7 	ldurb	w7, [x5, #-6]
    2de8:	aa0740c7 	orr	x7, x6, x7, lsl #16
    2dec:	385fb0a6 	ldurb	w6, [x5, #-5]
    2df0:	aa0660e6 	orr	x6, x7, x6, lsl #24
    2df4:	385fc0a7 	ldurb	w7, [x5, #-4]
    2df8:	aa0780c7 	orr	x7, x6, x7, lsl #32
    2dfc:	385fd0a6 	ldurb	w6, [x5, #-3]
    2e00:	aa06a0e6 	orr	x6, x7, x6, lsl #40
    2e04:	385fe0a7 	ldurb	w7, [x5, #-2]
    2e08:	aa07c0c7 	orr	x7, x6, x7, lsl #48
    2e0c:	385ff0a6 	ldurb	w6, [x5, #-1]
    2e10:	aa06e0e6 	orr	x6, x7, x6, lsl #56
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
    2e14:	381f8006 	sturb	w6, [x0, #-8]
	__put_unaligned_le16(val, p);
}

static inline void __put_unaligned_le64(u64 val, u8 *p)
{
	__put_unaligned_le32(val >> 32, p + 4);
    2e18:	d360fcc7 	lsr	x7, x6, #32
	*p++ = val;
    2e1c:	381fc007 	sturb	w7, [x0, #-4]
	__put_unaligned_le16(val >> 16, p + 2);
    2e20:	d370fcc8 	lsr	x8, x6, #48
	*p++ = val;
    2e24:	381fe008 	sturb	w8, [x0, #-2]
	*p++ = val >> 8;
    2e28:	53083ce7 	ubfx	w7, w7, #8, #8
    2e2c:	381fd007 	sturb	w7, [x0, #-3]
	__put_unaligned_le16(val >> 16, p + 2);
    2e30:	53107cc7 	lsr	w7, w6, #16
	*p++ = val >> 8;
    2e34:	53087d08 	lsr	w8, w8, #8
    2e38:	53083cc6 	ubfx	w6, w6, #8, #8
    2e3c:	381f9006 	sturb	w6, [x0, #-7]
	*p++ = val;
    2e40:	381fa007 	sturb	w7, [x0, #-6]
	*p++ = val >> 8;
    2e44:	53087ce7 	lsr	w7, w7, #8
    2e48:	381fb007 	sturb	w7, [x0, #-5]
    2e4c:	381ff008 	sturb	w8, [x0, #-1]
    2e50:	eb00009f 	cmp	x4, x0
    2e54:	54fffbe8 	b.hi	2dd0 <lz4_decompress+0xf4>  // b.pmore
		ip -= (op - cpy);
    2e58:	8b130326 	add	x6, x25, x19
		LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);
    2e5c:	38736b25 	ldrb	w5, [x25, x19]
		ip += 2;
    2e60:	910008c6 	add	x6, x6, #0x2
    2e64:	385ff0c0 	ldurb	w0, [x6, #-1]
    2e68:	2a0020a9 	orr	w9, w5, w0, lsl #8
		LZ4_READ_LITTLEENDIAN_16(ref, cpy, ip);
    2e6c:	aa0020a0 	orr	x0, x5, x0, lsl #8
    2e70:	cb000085 	sub	x5, x4, x0
		if (unlikely(ref < (BYTE *const) dest))
    2e74:	eb0502ff 	cmp	x23, x5
    2e78:	54fff968 	b.hi	2da4 <lz4_decompress+0xc8>  // b.pmore
		length = token & ML_MASK;
    2e7c:	12000c27 	and	w7, w1, #0xf
    2e80:	92400c21 	and	x1, x1, #0xf
		if (length == ML_MASK) {
    2e84:	71003cff 	cmp	w7, #0xf
    2e88:	54000181 	b.ne	2eb8 <lz4_decompress+0x1dc>  // b.any
		length = token & ML_MASK;
    2e8c:	d28001e1 	mov	x1, #0xf                   	// #15
    2e90:	14000003 	b	2e9c <lz4_decompress+0x1c0>
				ip++;
    2e94:	910004c6 	add	x6, x6, #0x1
			for (; *ip == 255; length += 255)
    2e98:	9103fc21 	add	x1, x1, #0xff
    2e9c:	394000c7 	ldrb	w7, [x6]
    2ea0:	7103fcff 	cmp	w7, #0xff
    2ea4:	54ffff80 	b.eq	2e94 <lz4_decompress+0x1b8>  // b.none
			if (unlikely(length > (size_t)(length + *ip)))
    2ea8:	2a0703e7 	mov	w7, w7
    2eac:	ab070021 	adds	x1, x1, x7
    2eb0:	54fff7a2 	b.cs	2da4 <lz4_decompress+0xc8>  // b.hs, b.nlast
			length += *ip++;
    2eb4:	910004c6 	add	x6, x6, #0x1
			op[0] = ref[0];
    2eb8:	394000a8 	ldrb	w8, [x5]
			op += STEPSIZE - 4;
    2ebc:	91002087 	add	x7, x4, #0x8
		if (unlikely((op - ref) < STEPSIZE)) {
    2ec0:	71001d3f 	cmp	w9, #0x7
    2ec4:	54000588 	b.hi	2f74 <lz4_decompress+0x298>  // b.pmore
			op[0] = ref[0];
    2ec8:	39000088 	strb	w8, [x4]
			size_t dec64 = dec64table[op - ref];
    2ecc:	d37df000 	lsl	x0, x0, #3
			op[1] = ref[1];
    2ed0:	394004a8 	ldrb	w8, [x5, #1]
    2ed4:	39000488 	strb	w8, [x4, #1]
			size_t dec64 = dec64table[op - ref];
    2ed8:	f8606869 	ldr	x9, [x3, x0]
			op[2] = ref[2];
    2edc:	394008a8 	ldrb	w8, [x5, #2]
    2ee0:	39000888 	strb	w8, [x4, #2]
			op[3] = ref[3];
    2ee4:	39400ca8 	ldrb	w8, [x5, #3]
    2ee8:	39000c88 	strb	w8, [x4, #3]
			ref -= dec32table[op-ref];
    2eec:	f8606b08 	ldr	x8, [x24, x0]
    2ef0:	d2800080 	mov	x0, #0x4                   	// #4
    2ef4:	cb080000 	sub	x0, x0, x8
    2ef8:	8b0000a8 	add	x8, x5, x0
			PUT4(ref, op);
    2efc:	386068a5 	ldrb	w5, [x5, x0]
    2f00:	39400500 	ldrb	w0, [x8, #1]
    2f04:	aa0020a0 	orr	x0, x5, x0, lsl #8
    2f08:	39400905 	ldrb	w5, [x8, #2]
    2f0c:	aa054005 	orr	x5, x0, x5, lsl #16
    2f10:	39400d00 	ldrb	w0, [x8, #3]
			ref -= dec64;
    2f14:	cb090108 	sub	x8, x8, x9
    2f18:	aa0060a0 	orr	x0, x5, x0, lsl #24
	*p++ = val;
    2f1c:	39001080 	strb	w0, [x4, #4]
	__put_unaligned_le16(val >> 16, p + 2);
    2f20:	53107c05 	lsr	w5, w0, #16
	*p++ = val >> 8;
    2f24:	53083c00 	ubfx	w0, w0, #8, #8
    2f28:	39001480 	strb	w0, [x4, #5]
	*p++ = val;
    2f2c:	39001885 	strb	w5, [x4, #6]
	*p++ = val >> 8;
    2f30:	53087ca5 	lsr	w5, w5, #8
    2f34:	39001c85 	strb	w5, [x4, #7]
		cpy = op + length - (STEPSIZE - 4);
    2f38:	d1001021 	sub	x1, x1, #0x4
    2f3c:	8b0100e0 	add	x0, x7, x1
		if (cpy > (oend - COPYLENGTH)) {
    2f40:	eb00005f 	cmp	x2, x0
    2f44:	54000b62 	b.cs	30b0 <lz4_decompress+0x3d4>  // b.hs, b.nlast
			if (cpy > oend)
    2f48:	eb0002df 	cmp	x22, x0
    2f4c:	54fff2c3 	b.cc	2da4 <lz4_decompress+0xc8>  // b.lo, b.ul, b.last
			LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));
    2f50:	eb07005f 	cmp	x2, x7
    2f54:	54000508 	b.hi	2ff4 <lz4_decompress+0x318>  // b.pmore
    2f58:	d2800001 	mov	x1, #0x0                   	// #0
			while (op < cpy)
    2f5c:	8b0100e4 	add	x4, x7, x1
    2f60:	eb04001f 	cmp	x0, x4
    2f64:	540009e8 	b.hi	30a0 <lz4_decompress+0x3c4>  // b.pmore
			if (op == oend)
    2f68:	eb0002df 	cmp	x22, x0
    2f6c:	54ffeec1 	b.ne	2d44 <lz4_decompress+0x68>  // b.any
    2f70:	17ffff8d 	b	2da4 <lz4_decompress+0xc8>
	return (u64)__get_unaligned_le32(p + 4) << 32 |
    2f74:	394000a8 	ldrb	w8, [x5]
    2f78:	394004a0 	ldrb	w0, [x5, #1]
    2f7c:	aa002100 	orr	x0, x8, x0, lsl #8
    2f80:	394008a8 	ldrb	w8, [x5, #2]
    2f84:	aa084008 	orr	x8, x0, x8, lsl #16
    2f88:	39400ca0 	ldrb	w0, [x5, #3]
    2f8c:	aa006100 	orr	x0, x8, x0, lsl #24
    2f90:	394010a8 	ldrb	w8, [x5, #4]
    2f94:	aa088008 	orr	x8, x0, x8, lsl #32
    2f98:	394014a0 	ldrb	w0, [x5, #5]
    2f9c:	aa00a100 	orr	x0, x8, x0, lsl #40
    2fa0:	394018a8 	ldrb	w8, [x5, #6]
    2fa4:	aa08c008 	orr	x8, x0, x8, lsl #48
    2fa8:	39401ca0 	ldrb	w0, [x5, #7]
    2fac:	aa00e100 	orr	x0, x8, x0, lsl #56
	*p++ = val;
    2fb0:	39000080 	strb	w0, [x4]
	__put_unaligned_le32(val >> 32, p + 4);
    2fb4:	d360fc08 	lsr	x8, x0, #32
	*p++ = val;
    2fb8:	39001088 	strb	w8, [x4, #4]
	__put_unaligned_le16(val >> 16, p + 2);
    2fbc:	d370fc09 	lsr	x9, x0, #48
	*p++ = val;
    2fc0:	39001889 	strb	w9, [x4, #6]
	*p++ = val >> 8;
    2fc4:	53083d08 	ubfx	w8, w8, #8, #8
    2fc8:	39001488 	strb	w8, [x4, #5]
	__put_unaligned_le16(val >> 16, p + 2);
    2fcc:	53107c08 	lsr	w8, w0, #16
	*p++ = val;
    2fd0:	39000888 	strb	w8, [x4, #2]
	*p++ = val >> 8;
    2fd4:	53087d29 	lsr	w9, w9, #8
    2fd8:	53083c00 	ubfx	w0, w0, #8, #8
    2fdc:	53087d08 	lsr	w8, w8, #8
    2fe0:	39000480 	strb	w0, [x4, #1]
    2fe4:	39000c88 	strb	w8, [x4, #3]
			LZ4_COPYSTEP(ref, op);
    2fe8:	910020a8 	add	x8, x5, #0x8
    2fec:	39001c89 	strb	w9, [x4, #7]
    2ff0:	17ffffd2 	b	2f38 <lz4_decompress+0x25c>
    2ff4:	aa0703e1 	mov	x1, x7
    2ff8:	aa0803e9 	mov	x9, x8
	return (u64)__get_unaligned_le32(p + 4) << 32 |
    2ffc:	3940012a 	ldrb	w10, [x9]
			LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));
    3000:	91002021 	add	x1, x1, #0x8
    3004:	39400525 	ldrb	w5, [x9, #1]
    3008:	91002129 	add	x9, x9, #0x8
    300c:	aa052145 	orr	x5, x10, x5, lsl #8
    3010:	385fa12a 	ldurb	w10, [x9, #-6]
    3014:	aa0a40aa 	orr	x10, x5, x10, lsl #16
    3018:	385fb125 	ldurb	w5, [x9, #-5]
    301c:	aa056145 	orr	x5, x10, x5, lsl #24
    3020:	385fc12a 	ldurb	w10, [x9, #-4]
    3024:	aa0a80aa 	orr	x10, x5, x10, lsl #32
    3028:	385fd125 	ldurb	w5, [x9, #-3]
    302c:	aa05a145 	orr	x5, x10, x5, lsl #40
    3030:	385fe12a 	ldurb	w10, [x9, #-2]
    3034:	aa0ac0aa 	orr	x10, x5, x10, lsl #48
    3038:	385ff125 	ldurb	w5, [x9, #-1]
    303c:	aa05e145 	orr	x5, x10, x5, lsl #56
	*p++ = val;
    3040:	381f8025 	sturb	w5, [x1, #-8]
	__put_unaligned_le32(val >> 32, p + 4);
    3044:	d360fcaa 	lsr	x10, x5, #32
	*p++ = val;
    3048:	381fc02a 	sturb	w10, [x1, #-4]
	__put_unaligned_le16(val >> 16, p + 2);
    304c:	d370fcab 	lsr	x11, x5, #48
	*p++ = val;
    3050:	381fe02b 	sturb	w11, [x1, #-2]
	*p++ = val >> 8;
    3054:	53083d4a 	ubfx	w10, w10, #8, #8
    3058:	381fd02a 	sturb	w10, [x1, #-3]
	__put_unaligned_le16(val >> 16, p + 2);
    305c:	53107caa 	lsr	w10, w5, #16
	*p++ = val >> 8;
    3060:	53087d6b 	lsr	w11, w11, #8
    3064:	53083ca5 	ubfx	w5, w5, #8, #8
    3068:	381f9025 	sturb	w5, [x1, #-7]
	*p++ = val;
    306c:	381fa02a 	sturb	w10, [x1, #-6]
	*p++ = val >> 8;
    3070:	53087d4a 	lsr	w10, w10, #8
    3074:	381fb02a 	sturb	w10, [x1, #-5]
    3078:	381ff02b 	sturb	w11, [x1, #-1]
    307c:	eb01005f 	cmp	x2, x1
    3080:	54fffbe8 	b.hi	2ffc <lz4_decompress+0x320>  // b.pmore
    3084:	d10046c1 	sub	x1, x22, #0x11
    3088:	cb040021 	sub	x1, x1, x4
    308c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    3090:	91002021 	add	x1, x1, #0x8
    3094:	8b010108 	add	x8, x8, x1
    3098:	8b0100e7 	add	x7, x7, x1
    309c:	17ffffaf 	b	2f58 <lz4_decompress+0x27c>
				*op++ = *ref++;
    30a0:	38616904 	ldrb	w4, [x8, x1]
    30a4:	382168e4 	strb	w4, [x7, x1]
    30a8:	91000421 	add	x1, x1, #0x1
    30ac:	17ffffac 	b	2f5c <lz4_decompress+0x280>
		LZ4_SECURECOPY(ref, op, cpy);
    30b0:	eb07001f 	cmp	x0, x7
    30b4:	54ffe489 	b.ls	2d44 <lz4_decompress+0x68>  // b.plast
	return (u64)__get_unaligned_le32(p + 4) << 32 |
    30b8:	39400101 	ldrb	w1, [x8]
    30bc:	910020e7 	add	x7, x7, #0x8
    30c0:	39400504 	ldrb	w4, [x8, #1]
    30c4:	91002108 	add	x8, x8, #0x8
    30c8:	aa042024 	orr	x4, x1, x4, lsl #8
    30cc:	385fa101 	ldurb	w1, [x8, #-6]
    30d0:	aa014081 	orr	x1, x4, x1, lsl #16
    30d4:	385fb104 	ldurb	w4, [x8, #-5]
    30d8:	aa046024 	orr	x4, x1, x4, lsl #24
    30dc:	385fc101 	ldurb	w1, [x8, #-4]
    30e0:	aa018081 	orr	x1, x4, x1, lsl #32
    30e4:	385fd104 	ldurb	w4, [x8, #-3]
    30e8:	aa04a024 	orr	x4, x1, x4, lsl #40
    30ec:	385fe101 	ldurb	w1, [x8, #-2]
    30f0:	aa01c081 	orr	x1, x4, x1, lsl #48
    30f4:	385ff104 	ldurb	w4, [x8, #-1]
    30f8:	aa04e024 	orr	x4, x1, x4, lsl #56
	*p++ = val;
    30fc:	381f80e4 	sturb	w4, [x7, #-8]
	__put_unaligned_le32(val >> 32, p + 4);
    3100:	d360fc81 	lsr	x1, x4, #32
	*p++ = val;
    3104:	381fc0e1 	sturb	w1, [x7, #-4]
	__put_unaligned_le16(val >> 16, p + 2);
    3108:	d370fc85 	lsr	x5, x4, #48
	*p++ = val;
    310c:	381fe0e5 	sturb	w5, [x7, #-2]
	*p++ = val >> 8;
    3110:	53083c21 	ubfx	w1, w1, #8, #8
    3114:	381fd0e1 	sturb	w1, [x7, #-3]
	__put_unaligned_le16(val >> 16, p + 2);
    3118:	53107c81 	lsr	w1, w4, #16
	*p++ = val >> 8;
    311c:	53087ca5 	lsr	w5, w5, #8
    3120:	53083c84 	ubfx	w4, w4, #8, #8
    3124:	381f90e4 	sturb	w4, [x7, #-7]
	*p++ = val;
    3128:	381fa0e1 	sturb	w1, [x7, #-6]
	*p++ = val >> 8;
    312c:	53087c21 	lsr	w1, w1, #8
    3130:	381fb0e1 	sturb	w1, [x7, #-5]
    3134:	381ff0e5 	sturb	w5, [x7, #-1]
    3138:	17ffffde 	b	30b0 <lz4_decompress+0x3d4>
	*src_len = input_len;
    313c:	93407e73 	sxtw	x19, w19
	return 0;
    3140:	52800000 	mov	w0, #0x0                   	// #0
	*src_len = input_len;
    3144:	f90002b3 	str	x19, [x21]
	return 0;
    3148:	17ffff18 	b	2da8 <lz4_decompress+0xcc>

000000000000314c <pbl_barebox_uncompress>:

	return memcmp(hash, computed_hash, SHA256_DIGEST_SIZE);
}

void pbl_barebox_uncompress(void *dest, void *compressed_start, unsigned int len)
{
    314c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    3150:	910003fd 	mov	x29, sp
    3154:	a90153f3 	stp	x19, x20, [sp, #16]
    3158:	a9025bf5 	stp	x21, x22, [sp, #32]
    315c:	a90363f7 	stp	x23, x24, [sp, #48]
    3160:	a9046bf9 	stp	x25, x26, [sp, #64]
	size_t out_len = get_unaligned_le32(input + in_len);
#endif
	size_t dest_len;


	if (output) {
    3164:	b5000080 	cbnz	x0, 3174 <pbl_barebox_uncompress+0x28>
		outp = output;
	} else if (!flush) {
		error("NULL output pointer and no flush function provided");
    3168:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    316c:	9126c400 	add	x0, x0, #0x9b1
		error("Both input pointer and fill function provided,");
		goto exit_1;
	} else if (input) {
		inp = input;
	} else if (!fill) {
		error("NULL input pointer and missing fill function");
    3170:	97fffe9a 	bl	2bd8 <errorfn>
	} else if (input) {
    3174:	b5000081 	cbnz	x1, 3184 <pbl_barebox_uncompress+0x38>
		error("NULL input pointer and missing fill function");
    3178:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    317c:	91279000 	add	x0, x0, #0x9e4
    3180:	17fffffc 	b	3170 <pbl_barebox_uncompress+0x24>
			goto exit_2;
		}
	}

	chunksize = get_unaligned_le32(inp);
	if (chunksize == ARCHIVE_MAGICNUMBER) {
    3184:	39400023 	ldrb	w3, [x1]
    3188:	aa0003f6 	mov	x22, x0
    318c:	39400420 	ldrb	w0, [x1, #1]
    3190:	aa002060 	orr	x0, x3, x0, lsl #8
    3194:	39400823 	ldrb	w3, [x1, #2]
    3198:	aa034003 	orr	x3, x0, x3, lsl #16
    319c:	39400c20 	ldrb	w0, [x1, #3]
    31a0:	aa006060 	orr	x0, x3, x0, lsl #24
    31a4:	52842043 	mov	w3, #0x2102                	// #8450
    31a8:	72a30983 	movk	w3, #0x184c, lsl #16
    31ac:	6b03001f 	cmp	w0, w3
    31b0:	54000541 	b.ne	3258 <pbl_barebox_uncompress+0x10c>  // b.any
			putc_ll('!');
			panic("hash mismatch, refusing to decompress");
		}
	}

	decompress((void *)compressed_start,
    31b4:	2a0203f4 	mov	w20, w2
				goto exit_2;
			}
		}

		chunksize = get_unaligned_le32(inp);
		if (chunksize == ARCHIVE_MAGICNUMBER) {
    31b8:	d2842059 	mov	x25, #0x2102                	// #8450
			      unsigned char *output,
			      long *posp,
			      void(*error)(char *x)
	)
{
	return unlz4(buf, in_len - 4, fill, flush, output, posp, error);
    31bc:	d1001294 	sub	x20, x20, #0x4
			inp += 4;
    31c0:	91001033 	add	x19, x1, #0x4
	size_t out_len = get_unaligned_le32(input + in_len);
    31c4:	8b140022 	add	x2, x1, x20
		ret = lz4_decompress(inp, &chunksize, outp, dest_len);
    31c8:	910163f8 	add	x24, sp, #0x58
		if (chunksize == ARCHIVE_MAGICNUMBER) {
    31cc:	f2a30999 	movk	x25, #0x184c, lsl #16
		if (out_len >= uncomp_chunksize) {
    31d0:	b2405bfa 	mov	x26, #0x7fffff              	// #8388607
	size_t out_len = get_unaligned_le32(input + in_len);
    31d4:	38746820 	ldrb	w0, [x1, x20]
			size -= 4;
    31d8:	51001294 	sub	w20, w20, #0x4
	size_t out_len = get_unaligned_le32(input + in_len);
    31dc:	39400443 	ldrb	w3, [x2, #1]
    31e0:	39400c55 	ldrb	w21, [x2, #3]
    31e4:	aa032003 	orr	x3, x0, x3, lsl #8
    31e8:	39400840 	ldrb	w0, [x2, #2]
    31ec:	aa004060 	orr	x0, x3, x0, lsl #16
    31f0:	aa156015 	orr	x21, x0, x21, lsl #24
		chunksize = get_unaligned_le32(inp);
    31f4:	39400261 	ldrb	w1, [x19]
				size -= 4;
    31f8:	51001294 	sub	w20, w20, #0x4
		chunksize = get_unaligned_le32(inp);
    31fc:	39400660 	ldrb	w0, [x19, #1]
				inp += 4;
    3200:	91001273 	add	x19, x19, #0x4
		chunksize = get_unaligned_le32(inp);
    3204:	385fe262 	ldurb	w2, [x19, #-2]
    3208:	aa002020 	orr	x0, x1, x0, lsl #8
    320c:	aa024002 	orr	x2, x0, x2, lsl #16
    3210:	385ff260 	ldurb	w0, [x19, #-1]
    3214:	aa006040 	orr	x0, x2, x0, lsl #24
    3218:	f9002fe0 	str	x0, [sp, #88]
		if (chunksize == ARCHIVE_MAGICNUMBER) {
    321c:	eb19001f 	cmp	x0, x25
    3220:	54fffea0 	b.eq	31f4 <pbl_barebox_uncompress+0xa8>  // b.none
		if (out_len >= uncomp_chunksize) {
    3224:	eb1a02bf 	cmp	x21, x26
    3228:	540001e9 	b.ls	3264 <pbl_barebox_uncompress+0x118>  // b.plast
			out_len -= dest_len;
    322c:	d16002b5 	sub	x21, x21, #0x800, lsl #12
			dest_len = uncomp_chunksize;
    3230:	d2a01017 	mov	x23, #0x800000              	// #8388608
		ret = lz4_decompress(inp, &chunksize, outp, dest_len);
    3234:	aa1703e3 	mov	x3, x23
    3238:	aa1603e2 	mov	x2, x22
    323c:	aa1803e1 	mov	x1, x24
    3240:	aa1303e0 	mov	x0, x19
    3244:	97fffea6 	bl	2cdc <lz4_decompress>
		if (ret < 0) {
    3248:	36f80120 	tbz	w0, #31, 326c <pbl_barebox_uncompress+0x120>
			error("Decoding failed");
    324c:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    3250:	91288000 	add	x0, x0, #0xa20
    3254:	17ffffc7 	b	3170 <pbl_barebox_uncompress+0x24>
		error("invalid header");
    3258:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    325c:	91284400 	add	x0, x0, #0xa11
    3260:	17ffffc4 	b	3170 <pbl_barebox_uncompress+0x24>
			dest_len = out_len;
    3264:	aa1503f7 	mov	x23, x21
    3268:	17fffff3 	b	3234 <pbl_barebox_uncompress+0xe8>
			size -= chunksize;
    326c:	f9402fe0 	ldr	x0, [sp, #88]
			outp += dest_len;
    3270:	8b1702d6 	add	x22, x22, x23
			size -= chunksize;
    3274:	6b000294 	subs	w20, w20, w0
			if (size == 0)
    3278:	340000f4 	cbz	w20, 3294 <pbl_barebox_uncompress+0x148>
			else if (size < 0) {
    327c:	54000085 	b.pl	328c <pbl_barebox_uncompress+0x140>  // b.nfrst
				error("data corrupted");
    3280:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    3284:	9128c000 	add	x0, x0, #0xa30
    3288:	17ffffba 	b	3170 <pbl_barebox_uncompress+0x24>
			inp += chunksize;
    328c:	8b000273 	add	x19, x19, x0
    3290:	17ffffd9 	b	31f4 <pbl_barebox_uncompress+0xa8>
			len,
			NULL, NULL,
			dest, NULL, errorfn);
}
    3294:	a94153f3 	ldp	x19, x20, [sp, #16]
    3298:	a9425bf5 	ldp	x21, x22, [sp, #32]
    329c:	a94363f7 	ldp	x23, x24, [sp, #48]
    32a0:	a9446bf9 	ldp	x25, x26, [sp, #64]
    32a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
    32a8:	d65f03c0 	ret

00000000000032ac <fdt_find_mem>:

	return reg;
}

void fdt_find_mem(const void *fdt, unsigned long *membase, unsigned long *memsize)
{
    32ac:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    32b0:	910003fd 	mov	x29, sp
    32b4:	a90153f3 	stp	x19, x20, [sp, #16]
    32b8:	aa0003f4 	mov	x20, x0
    32bc:	a9025bf5 	stp	x21, x22, [sp, #32]
    32c0:	aa0203f6 	mov	x22, x2
    32c4:	f9001bf7 	str	x23, [sp, #48]
    32c8:	aa0103f7 	mov	x23, x1
	const __be32 *reg;
	int na, ns;
	uint64_t memsize64, membase64;
	int node, size;
    32cc:	b9004fff 	str	wzr, [sp, #76]

	/* Make sure FDT blob is sane */
	if (fdt_check_header(fdt) != 0) {
    32d0:	97fff3e0 	bl	250 <fdt_check_header>
    32d4:	34000140 	cbz	w0, 32fc <fdt_find_mem+0x50>
		pr_err("Invalid device tree blob\n");
    32d8:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    32dc:	9128fc21 	add	x1, x1, #0xa3f
		goto err;
	}

	reg = fdt_getprop(fdt, node, "reg", &size);
	if (size < (na + ns) * sizeof(u32)) {
		pr_err("cannot get memory range\n");
    32e0:	52800060 	mov	w0, #0x3                   	// #3
    32e4:	97fffe12 	bl	2b2c <pr_print>
	*membase = membase64;
	*memsize = memsize64;

	return;
err:
	pr_err("No memory, cannot continue\n");
    32e8:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    32ec:	52800060 	mov	w0, #0x3                   	// #3
    32f0:	912c0021 	add	x1, x1, #0xb00
    32f4:	97fffe0e 	bl	2b2c <pr_print>
	while (1);
    32f8:	14000000 	b	32f8 <fdt_find_mem+0x4c>
	node = fdt_path_offset(fdt, "/");
    32fc:	aa1403e0 	mov	x0, x20
    3300:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    3304:	91296421 	add	x1, x1, #0xa59
    3308:	97fff73a 	bl	ff0 <fdt_path_offset>
    330c:	2a0003f5 	mov	w21, w0
	if (node < 0) {
    3310:	36f80080 	tbz	w0, #31, 3320 <fdt_find_mem+0x74>
		pr_err("Cannot find root node\n");
    3314:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    3318:	91296c21 	add	x1, x1, #0xa5b
    331c:	17fffff1 	b	32e0 <fdt_find_mem+0x34>
	na = fdt_address_cells(fdt, node);
    3320:	2a0003e1 	mov	w1, w0
    3324:	aa1403e0 	mov	x0, x20
    3328:	97fff528 	bl	7c8 <fdt_address_cells>
    332c:	2a0003f3 	mov	w19, w0
	if (na < 0) {
    3330:	36f80080 	tbz	w0, #31, 3340 <fdt_find_mem+0x94>
		pr_err("Cannot find #address-cells property");
    3334:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    3338:	9129c821 	add	x1, x1, #0xa72
    333c:	17ffffe9 	b	32e0 <fdt_find_mem+0x34>
	ns = fdt_size_cells(fdt, node);
    3340:	2a1503e1 	mov	w1, w21
    3344:	aa1403e0 	mov	x0, x20
    3348:	97fff52d 	bl	7fc <fdt_size_cells>
    334c:	2a0003f5 	mov	w21, w0
	if (ns < 0) {
    3350:	36f80080 	tbz	w0, #31, 3360 <fdt_find_mem+0xb4>
		pr_err("Cannot find #size-cells property");
    3354:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    3358:	912a5821 	add	x1, x1, #0xa96
    335c:	17ffffe1 	b	32e0 <fdt_find_mem+0x34>
	node = fdt_node_offset_by_prop_value(fdt, -1, "device_type",
    3360:	12800001 	mov	w1, #0xffffffff            	// #-1
    3364:	aa1403e0 	mov	x0, x20
    3368:	528000e4 	mov	w4, #0x7                   	// #7
    336c:	90000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    3370:	90000002 	adrp	x2, 3000 <lz4_decompress+0x324>
    3374:	912adc63 	add	x3, x3, #0xab7
    3378:	912af842 	add	x2, x2, #0xabe
    337c:	97fff72b 	bl	1028 <fdt_node_offset_by_prop_value>
    3380:	2a0003e1 	mov	w1, w0
	if (node < 0) {
    3384:	36f80080 	tbz	w0, #31, 3394 <fdt_find_mem+0xe8>
		pr_err("Cannot find memory node\n");
    3388:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    338c:	912b2821 	add	x1, x1, #0xaca
    3390:	17ffffd4 	b	32e0 <fdt_find_mem+0x34>
	reg = fdt_getprop(fdt, node, "reg", &size);
    3394:	910133e3 	add	x3, sp, #0x4c
    3398:	aa1403e0 	mov	x0, x20
    339c:	90000002 	adrp	x2, 3000 <lz4_decompress+0x324>
    33a0:	912b8c42 	add	x2, x2, #0xae3
    33a4:	97fff6a8 	bl	e44 <fdt_getprop>
	if (size < (na + ns) * sizeof(u32)) {
    33a8:	b9804fe1 	ldrsw	x1, [sp, #76]
    33ac:	0b150262 	add	w2, w19, w21
    33b0:	eb22c83f 	cmp	x1, w2, sxtw #2
    33b4:	54000082 	b.cs	33c4 <fdt_find_mem+0x118>  // b.hs, b.nlast
		pr_err("cannot get memory range\n");
    33b8:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    33bc:	912b9c21 	add	x1, x1, #0xae7
    33c0:	17ffffc8 	b	32e0 <fdt_find_mem+0x34>
	for (i = 0; i < n; i++)
    33c4:	d2800001 	mov	x1, #0x0                   	// #0
	*val = 0;
    33c8:	d2800004 	mov	x4, #0x0                   	// #0
	for (i = 0; i < n; i++)
    33cc:	6b01027f 	cmp	w19, w1
    33d0:	540001a8 	b.hi	3404 <fdt_find_mem+0x158>  // b.pmore
    33d4:	8b33c813 	add	x19, x0, w19, sxtw #2
    33d8:	d2800001 	mov	x1, #0x0                   	// #0
	*val = 0;
    33dc:	d2800002 	mov	x2, #0x0                   	// #0
	for (i = 0; i < n; i++)
    33e0:	6b0102bf 	cmp	w21, w1
    33e4:	540001c8 	b.hi	341c <fdt_find_mem+0x170>  // b.pmore
	*membase = membase64;
    33e8:	f90002e4 	str	x4, [x23]
	*memsize = memsize64;
    33ec:	f90002c2 	str	x2, [x22]
}
    33f0:	a94153f3 	ldp	x19, x20, [sp, #16]
    33f4:	a9425bf5 	ldp	x21, x22, [sp, #32]
    33f8:	f9401bf7 	ldr	x23, [sp, #48]
    33fc:	a8c57bfd 	ldp	x29, x30, [sp], #80
    3400:	d65f03c0 	ret
    3404:	b8617803 	ldr	w3, [x0, x1, lsl #2]
    3408:	91000421 	add	x1, x1, #0x1
    340c:	5ac00863 	rev	w3, w3
		*val = (*val << 32) | fdt32_to_cpu(*reg++);
    3410:	2a0303e3 	mov	w3, w3
    3414:	aa048064 	orr	x4, x3, x4, lsl #32
	for (i = 0; i < n; i++)
    3418:	17ffffed 	b	33cc <fdt_find_mem+0x120>
    341c:	b8617a60 	ldr	w0, [x19, x1, lsl #2]
    3420:	91000421 	add	x1, x1, #0x1
    3424:	5ac00800 	rev	w0, w0
		*val = (*val << 32) | fdt32_to_cpu(*reg++);
    3428:	2a0003e0 	mov	w0, w0
    342c:	aa028002 	orr	x2, x0, x2, lsl #32
	for (i = 0; i < n; i++)
    3430:	17ffffec 	b	33e0 <fdt_find_mem+0x134>

0000000000003434 <handoff_data_get>:
	 * later). We force the handoff_data variable into the data segment.
	 * When moving the PBL somewhere else with handoff_data set we move the
	 * content of the variable with it and thus find it to have the correct
	 * value in the new PBL.
	 */
	if (handoff_data == (void *)-1) {
    3434:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    3438:	f946dc20 	ldr	x0, [x1, #3512]
    343c:	b100041f 	cmn	x0, #0x1
    3440:	540000c1 	b.ne	3458 <handoff_data_get+0x24>  // b.any
		handoff_data = &__handoff_data;
    3444:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    3448:	9136a000 	add	x0, x0, #0xda8
    344c:	f906dc20 	str	x0, [x1, #3512]
 * Initializes the list_head to point to itself.  If it is a list header,
 * the result is an empty list.
 */
static inline void INIT_LIST_HEAD(struct list_head *list)
{
	WRITE_ONCE(list->next, list);
    3450:	f9000000 	str	x0, [x0]
	list->prev = list;
    3454:	f9000400 	str	x0, [x0, #8]
		INIT_LIST_HEAD(&handoff_data->entries);
	}

	return handoff_data;
}
    3458:	f946dc20 	ldr	x0, [x1, #3512]
    345c:	d65f03c0 	ret

0000000000003460 <handoff_data_add_entry>:
 * @hde: the new entry
 *
 * This adds a new handoff data entry.
 */
void handoff_data_add_entry(struct handoff_data_entry *hde)
{
    3460:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    3464:	aa0003e2 	mov	x2, x0
    3468:	910003fd 	mov	x29, sp
	struct handoff_data *hd = handoff_data_get();
    346c:	97fffff2 	bl	3434 <handoff_data_get>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
    3470:	f9400401 	ldr	x1, [x0, #8]
	next->prev = new;
    3474:	f9000402 	str	x2, [x0, #8]
	new->prev = prev;
    3478:	a9000440 	stp	x0, x1, [x2]
	WRITE_ONCE(prev->next, new);
    347c:	f9000022 	str	x2, [x1]

	list_add_tail(&hde->list, &hd->entries);
}
    3480:	a8c17bfd 	ldp	x29, x30, [sp], #16
    3484:	d65f03c0 	ret

0000000000003488 <__handoff_data_size>:
{
	struct handoff_data_entry *hde;
	size_t size = 0;
	size_t dsize = 0;

	if (!hd)
    3488:	b5000260 	cbnz	x0, 34d4 <__handoff_data_size+0x4c>
{
    348c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
		hd = handoff_data_get();

	dsize += sizeof(*hd);
    3490:	d2800203 	mov	x3, #0x10                  	// #16
	size_t size = 0;
    3494:	d2800004 	mov	x4, #0x0                   	// #0
{
    3498:	910003fd 	mov	x29, sp
		hd = handoff_data_get();
    349c:	97ffffe6 	bl	3434 <handoff_data_get>

	list_for_each_entry(hde, &hd->entries, list) {
    34a0:	f9400002 	ldr	x2, [x0]
    34a4:	eb02001f 	cmp	x0, x2
    34a8:	54000081 	b.ne	34b8 <__handoff_data_size+0x30>  // b.any
		dsize += sizeof(*hde);
		size += ALIGN(hde->size, 8);
	}

	return dsize + size;
}
    34ac:	8b030080 	add	x0, x4, x3
    34b0:	a8c17bfd 	ldp	x29, x30, [sp], #16
    34b4:	d65f03c0 	ret
		size += ALIGN(hde->size, 8);
    34b8:	f9400c41 	ldr	x1, [x2, #24]
		dsize += sizeof(*hde);
    34bc:	9100a063 	add	x3, x3, #0x28
	list_for_each_entry(hde, &hd->entries, list) {
    34c0:	f9400042 	ldr	x2, [x2]
		size += ALIGN(hde->size, 8);
    34c4:	91001c21 	add	x1, x1, #0x7
    34c8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    34cc:	8b010084 	add	x4, x4, x1
	list_for_each_entry(hde, &hd->entries, list) {
    34d0:	17fffff5 	b	34a4 <__handoff_data_size+0x1c>
    34d4:	f9400002 	ldr	x2, [x0]
	dsize += sizeof(*hd);
    34d8:	d2800203 	mov	x3, #0x10                  	// #16
	size_t size = 0;
    34dc:	d2800004 	mov	x4, #0x0                   	// #0
	list_for_each_entry(hde, &hd->entries, list) {
    34e0:	eb02001f 	cmp	x0, x2
    34e4:	54000061 	b.ne	34f0 <__handoff_data_size+0x68>  // b.any
}
    34e8:	8b030080 	add	x0, x4, x3
    34ec:	d65f03c0 	ret
		size += ALIGN(hde->size, 8);
    34f0:	f9400c41 	ldr	x1, [x2, #24]
		dsize += sizeof(*hde);
    34f4:	9100a063 	add	x3, x3, #0x28
	list_for_each_entry(hde, &hd->entries, list) {
    34f8:	f9400042 	ldr	x2, [x2]
		size += ALIGN(hde->size, 8);
    34fc:	91001c21 	add	x1, x1, #0x7
    3500:	927df021 	and	x1, x1, #0xfffffffffffffff8
    3504:	8b010084 	add	x4, x4, x1
	list_for_each_entry(hde, &hd->entries, list) {
    3508:	17fffff6 	b	34e0 <__handoff_data_size+0x58>

000000000000350c <handoff_data_move>:
 * to @dest. This can be used to move the handoff data to a contiguous
 * region outside the binary. Note once moved no data should be added,
 * as that would make the handoff_data discontigoous again.
 */
void handoff_data_move(void *dest)
{
    350c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    3510:	910003fd 	mov	x29, sp
    3514:	a90153f3 	stp	x19, x20, [sp, #16]
    3518:	aa0003f3 	mov	x19, x0
	struct handoff_data *hdnew = dest;
	struct handoff_data_entry *hde;

	INIT_LIST_HEAD(&hdnew->entries);

	dest = hdnew + 1;
    351c:	91004014 	add	x20, x0, #0x10
{
    3520:	a9025bf5 	stp	x21, x22, [sp, #32]
    3524:	f9001bf7 	str	x23, [sp, #48]
	struct handoff_data *hd = handoff_data_get();
    3528:	97ffffc3 	bl	3434 <handoff_data_get>
	WRITE_ONCE(list->next, list);
    352c:	f9000273 	str	x19, [x19]
    3530:	aa0003f7 	mov	x23, x0
	list->prev = list;
    3534:	f9000673 	str	x19, [x19, #8]

	list_for_each_entry(hde, &hd->entries, list) {
    3538:	f9400015 	ldr	x21, [x0]
    353c:	eb1702bf 	cmp	x21, x23
    3540:	54000101 	b.ne	3560 <handoff_data_move+0x54>  // b.any
	handoff_data = handoff;
    3544:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
		newde->flags = hde->flags;
		list_add_tail(&newde->list, &hdnew->entries);
	}

	handoff_data_set(hdnew);
}
    3548:	a9425bf5 	ldp	x21, x22, [sp, #32]
	handoff_data = handoff;
    354c:	f906dc13 	str	x19, [x0, #3512]
}
    3550:	a94153f3 	ldp	x19, x20, [sp, #16]
    3554:	f9401bf7 	ldr	x23, [sp, #48]
    3558:	a8c47bfd 	ldp	x29, x30, [sp], #64
    355c:	d65f03c0 	ret
		if (hde->flags & HANDOFF_DATA_FLAG_NO_COPY) {
    3560:	b94026a0 	ldr	w0, [x21, #36]
		dest = newde + 1;
    3564:	9100a296 	add	x22, x20, #0x28
			newde->data = hde->data;
    3568:	f9400aa1 	ldr	x1, [x21, #16]
		if (hde->flags & HANDOFF_DATA_FLAG_NO_COPY) {
    356c:	360001e0 	tbz	w0, #0, 35a8 <handoff_data_move+0x9c>
			newde->data = hde->data;
    3570:	f9000a81 	str	x1, [x20, #16]
		newde->size = hde->size;
    3574:	f9400ea0 	ldr	x0, [x21, #24]
    3578:	f9000e80 	str	x0, [x20, #24]
		newde->cookie = hde->cookie;
    357c:	b94022a0 	ldr	w0, [x21, #32]
    3580:	b9002280 	str	w0, [x20, #32]
		newde->flags = hde->flags;
    3584:	b94026a0 	ldr	w0, [x21, #36]
    3588:	b9002680 	str	w0, [x20, #36]
	__list_add(new, head->prev, head);
    358c:	f9400660 	ldr	x0, [x19, #8]
	next->prev = new;
    3590:	f9000674 	str	x20, [x19, #8]
	new->prev = prev;
    3594:	a9000293 	stp	x19, x0, [x20]
	WRITE_ONCE(prev->next, new);
    3598:	f9000014 	str	x20, [x0]
	list_for_each_entry(hde, &hd->entries, list) {
    359c:	aa1603f4 	mov	x20, x22
    35a0:	f94002b5 	ldr	x21, [x21]
    35a4:	17ffffe6 	b	353c <handoff_data_move+0x30>
			memcpy(dest, hde->data, hde->size);
    35a8:	f9400ea2 	ldr	x2, [x21, #24]
    35ac:	aa1603e0 	mov	x0, x22
    35b0:	9400005d 	bl	3724 <__memcpy>
			newde->data = dest;
    35b4:	f9000a96 	str	x22, [x20, #16]
			dest += ALIGN(hde->size, 8);
    35b8:	f9400ea1 	ldr	x1, [x21, #24]
    35bc:	91001c21 	add	x1, x1, #0x7
    35c0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    35c4:	8b0102d6 	add	x22, x22, x1
    35c8:	17ffffeb 	b	3574 <handoff_data_move+0x68>

00000000000035cc <handoff_data_add_dt>:

	return 0;
}

void handoff_data_add_dt(void *fdt)
{
    35cc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    35d0:	aa0003e1 	mov	x1, x0
    35d4:	910003fd 	mov	x29, sp
    35d8:	39400002 	ldrb	w2, [x0]
    35dc:	39400400 	ldrb	w0, [x0, #1]
    35e0:	aa002040 	orr	x0, x2, x0, lsl #8
    35e4:	39400822 	ldrb	w2, [x1, #2]
    35e8:	aa024002 	orr	x2, x0, x2, lsl #16
    35ec:	39400c20 	ldrb	w0, [x1, #3]
    35f0:	aa006040 	orr	x0, x2, x0, lsl #24
	if (blob_is_fdt(fdt)) {
    35f4:	5281ba02 	mov	w2, #0xdd0                 	// #3536
    35f8:	72bdbfc2 	movk	w2, #0xedfe, lsl #16
    35fc:	6b02001f 	cmp	w0, w2
    3600:	54000421 	b.ne	3684 <handoff_data_add_dt+0xb8>  // b.any
		handoff_data_add(HANDOFF_DATA_INTERNAL_DT, fdt,
    3604:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    3608:	91360000 	add	x0, x0, #0xd80
    360c:	b9402002 	ldr	w2, [x0, #32]
    3610:	34000182 	cbz	w2, 3640 <handoff_data_add_dt+0x74>
    3614:	90000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    3618:	91318063 	add	x3, x3, #0xc60
    361c:	52801522 	mov	w2, #0xa9                  	// #169
				 get_unaligned_be32(fdt + 4));
	} else if (blob_is_compressed_fdt(fdt)) {
		struct barebox_boarddata_compressed_dtb *bd = fdt;

		handoff_data_add(HANDOFF_DATA_INTERNAL_DT_Z, fdt,
    3620:	90000001 	adrp	x1, 3000 <lz4_decompress+0x324>
    3624:	912c7021 	add	x1, x1, #0xb1c
    3628:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    362c:	91254400 	add	x0, x0, #0x951
    3630:	97fffd13 	bl	2a7c <printf>
    3634:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    3638:	9125b800 	add	x0, x0, #0x96e
    363c:	94000026 	bl	36d4 <panic>
		handoff_data_add(HANDOFF_DATA_INTERNAL_DT, fdt,
    3640:	52832e22 	mov	w2, #0x1971                	// #6513
    3644:	f9000801 	str	x1, [x0, #16]
    3648:	72a500c2 	movk	w2, #0x2806, lsl #16
    364c:	b9002002 	str	w2, [x0, #32]
    3650:	39401022 	ldrb	w2, [x1, #4]
    3654:	39401423 	ldrb	w3, [x1, #5]
    3658:	aa032043 	orr	x3, x2, x3, lsl #8
    365c:	39401822 	ldrb	w2, [x1, #6]
    3660:	39401c21 	ldrb	w1, [x1, #7]
    3664:	aa024062 	orr	x2, x3, x2, lsl #16
    3668:	aa016041 	orr	x1, x2, x1, lsl #24
    366c:	5ac00821 	rev	w1, w1
		handoff_data_add(HANDOFF_DATA_INTERNAL_DT_Z, fdt,
    3670:	f9000c01 	str	x1, [x0, #24]
    3674:	b900241f 	str	wzr, [x0, #36]
    3678:	97ffff7a 	bl	3460 <handoff_data_add_entry>
				 bd->datalen + sizeof(*bd));
	}
}
    367c:	a8c17bfd 	ldp	x29, x30, [sp], #16
    3680:	d65f03c0 	ret
	} else if (blob_is_compressed_fdt(fdt)) {
    3684:	529797a2 	mov	w2, #0xbcbd                	// #48317
    3688:	72af6cc2 	movk	w2, #0x7b66, lsl #16
    368c:	6b02001f 	cmp	w0, w2
    3690:	54ffff61 	b.ne	367c <handoff_data_add_dt+0xb0>  // b.any
		handoff_data_add(HANDOFF_DATA_INTERNAL_DT_Z, fdt,
    3694:	90000000 	adrp	x0, 3000 <lz4_decompress+0x324>
    3698:	91356000 	add	x0, x0, #0xd58
    369c:	b9402002 	ldr	w2, [x0, #32]
    36a0:	340000a2 	cbz	w2, 36b4 <handoff_data_add_dt+0xe8>
    36a4:	90000003 	adrp	x3, 3000 <lz4_decompress+0x324>
    36a8:	528015c2 	mov	w2, #0xae                  	// #174
    36ac:	91318063 	add	x3, x3, #0xc60
    36b0:	17ffffdc 	b	3620 <handoff_data_add_dt+0x54>
    36b4:	52832e42 	mov	w2, #0x1972                	// #6514
    36b8:	f9000801 	str	x1, [x0, #16]
    36bc:	72a500c2 	movk	w2, #0x2806, lsl #16
    36c0:	b9002002 	str	w2, [x0, #32]
    36c4:	b9400421 	ldr	w1, [x1, #4]
    36c8:	91003021 	add	x1, x1, #0xc
    36cc:	17ffffe9 	b	3670 <handoff_data_add_dt+0xa4>

00000000000036d0 <hang>:
#include <linux/string.h>
#include <linux/ctype.h>

void __noreturn hang(void)
{
	while (1);
    36d0:	14000000 	b	36d0 <hang>

00000000000036d4 <panic>:
}

void __noreturn panic(const char *fmt, ...)
{
    36d4:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
    36d8:	910003fd 	mov	x29, sp
    36dc:	a9058be1 	stp	x1, x2, [sp, #88]
	va_list args;

	va_start(args, fmt);
    36e0:	910243e1 	add	x1, sp, #0x90
    36e4:	a90307e1 	stp	x1, x1, [sp, #48]
    36e8:	910143e1 	add	x1, sp, #0x50
    36ec:	f90023e1 	str	x1, [sp, #64]
    36f0:	128006e1 	mov	w1, #0xffffffc8            	// #-56
    36f4:	b9004be1 	str	w1, [sp, #72]
	printf(fmt, args);
    36f8:	910043e1 	add	x1, sp, #0x10
	va_start(args, fmt);
    36fc:	b9004fff 	str	wzr, [sp, #76]
{
    3700:	a90693e3 	stp	x3, x4, [sp, #104]
	printf(fmt, args);
    3704:	a9430fe2 	ldp	x2, x3, [sp, #48]
    3708:	a9010fe2 	stp	x2, x3, [sp, #16]
    370c:	a9440fe2 	ldp	x2, x3, [sp, #64]
    3710:	a9020fe2 	stp	x2, x3, [sp, #32]
{
    3714:	a9079be5 	stp	x5, x6, [sp, #120]
    3718:	f90047e7 	str	x7, [sp, #136]
	printf(fmt, args);
    371c:	97fffcd8 	bl	2a7c <printf>
	va_end(args);
	while(1);
    3720:	14000000 	b	3720 <panic+0x4c>

0000000000003724 <__memcpy>:
void *memcpy(void *__dest, __const void *__src, size_t __n)
{
	int i = 0;
	unsigned char *d = (unsigned char *)__dest, *s = (unsigned char *)__src;

	for (i = __n >> 3; i > 0; i--) {
    3724:	d343fc46 	lsr	x6, x2, #3
	unsigned char *d = (unsigned char *)__dest, *s = (unsigned char *)__src;
    3728:	aa0103e4 	mov	x4, x1
    372c:	aa0003e3 	mov	x3, x0
	for (i = __n >> 3; i > 0; i--) {
    3730:	2a0603e5 	mov	w5, w6
    3734:	710000bf 	cmp	w5, #0x0
    3738:	540003cc 	b.gt	37b0 <__memcpy+0x8c>
    373c:	710000df 	cmp	w6, #0x0
    3740:	d37d7cc5 	ubfiz	x5, x6, #3, #32
    3744:	9a9fa0a5 	csel	x5, x5, xzr, ge	// ge = tcont
    3748:	8b050003 	add	x3, x0, x5
    374c:	8b050024 	add	x4, x1, x5
		*d++ = *s++;
		*d++ = *s++;
		*d++ = *s++;
	}

	if (__n & 1 << 2) {
    3750:	36100162 	tbz	w2, #2, 377c <__memcpy+0x58>
		*d++ = *s++;
    3754:	38656821 	ldrb	w1, [x1, x5]
		*d++ = *s++;
		*d++ = *s++;
		*d++ = *s++;
    3758:	91001084 	add	x4, x4, #0x4
		*d++ = *s++;
    375c:	38256801 	strb	w1, [x0, x5]
		*d++ = *s++;
    3760:	91001063 	add	x3, x3, #0x4
		*d++ = *s++;
    3764:	385fd081 	ldurb	w1, [x4, #-3]
    3768:	381fd061 	sturb	w1, [x3, #-3]
		*d++ = *s++;
    376c:	385fe081 	ldurb	w1, [x4, #-2]
    3770:	381fe061 	sturb	w1, [x3, #-2]
		*d++ = *s++;
    3774:	385ff081 	ldurb	w1, [x4, #-1]
    3778:	381ff061 	sturb	w1, [x3, #-1]
	}

	if (__n & 1 << 1) {
    377c:	36080122 	tbz	w2, #1, 37a0 <__memcpy+0x7c>
		*d++ = *s++;
    3780:	aa0403e5 	mov	x5, x4
    3784:	aa0303e1 	mov	x1, x3
    3788:	384024a6 	ldrb	w6, [x5], #2
    378c:	38002426 	strb	w6, [x1], #2
		*d++ = *s++;
    3790:	39400484 	ldrb	w4, [x4, #1]
    3794:	39000464 	strb	w4, [x3, #1]
    3798:	aa0503e4 	mov	x4, x5
    379c:	aa0103e3 	mov	x3, x1
	}

	if (__n & 1)
    37a0:	36000062 	tbz	w2, #0, 37ac <__memcpy+0x88>
		*d++ = *s++;
    37a4:	39400081 	ldrb	w1, [x4]
    37a8:	39000061 	strb	w1, [x3]

	return __dest;
}
    37ac:	d65f03c0 	ret
		*d++ = *s++;
    37b0:	39400087 	ldrb	w7, [x4]
		*d++ = *s++;
    37b4:	91002084 	add	x4, x4, #0x8
		*d++ = *s++;
    37b8:	39000067 	strb	w7, [x3]
		*d++ = *s++;
    37bc:	91002063 	add	x3, x3, #0x8
	for (i = __n >> 3; i > 0; i--) {
    37c0:	510004a5 	sub	w5, w5, #0x1
		*d++ = *s++;
    37c4:	385f9087 	ldurb	w7, [x4, #-7]
    37c8:	381f9067 	sturb	w7, [x3, #-7]
		*d++ = *s++;
    37cc:	385fa087 	ldurb	w7, [x4, #-6]
    37d0:	381fa067 	sturb	w7, [x3, #-6]
		*d++ = *s++;
    37d4:	385fb087 	ldurb	w7, [x4, #-5]
    37d8:	381fb067 	sturb	w7, [x3, #-5]
		*d++ = *s++;
    37dc:	385fc087 	ldurb	w7, [x4, #-4]
    37e0:	381fc067 	sturb	w7, [x3, #-4]
		*d++ = *s++;
    37e4:	385fd087 	ldurb	w7, [x4, #-3]
    37e8:	381fd067 	sturb	w7, [x3, #-3]
		*d++ = *s++;
    37ec:	385fe087 	ldurb	w7, [x4, #-2]
    37f0:	381fe067 	sturb	w7, [x3, #-2]
		*d++ = *s++;
    37f4:	385ff087 	ldurb	w7, [x4, #-1]
    37f8:	381ff067 	sturb	w7, [x3, #-1]
	for (i = __n >> 3; i > 0; i--) {
    37fc:	17ffffce 	b	3734 <__memcpy+0x10>

0000000000003800 <strlen>:
	return __dest;
}

size_t strlen(const char *s)
{
	const char *sc = s;
    3800:	aa0003e1 	mov	x1, x0

	while (*sc != '\0')
    3804:	39400022 	ldrb	w2, [x1]
    3808:	35000062 	cbnz	w2, 3814 <strlen+0x14>
		sc++;
	return sc - s;
}
    380c:	cb000020 	sub	x0, x1, x0
    3810:	d65f03c0 	ret
		sc++;
    3814:	91000421 	add	x1, x1, #0x1
    3818:	17fffffb 	b	3804 <strlen+0x4>

000000000000381c <memcmp>:

int memcmp(const void *cs, const void *ct, size_t count)
{
    381c:	aa0003e5 	mov	x5, x0
	const unsigned char *su1 = cs, *su2 = ct, *end = su1 + count;
    3820:	8b020002 	add	x2, x0, x2
	int res = 0;

	while (su1 < end) {
    3824:	d2800004 	mov	x4, #0x0                   	// #0
    3828:	8b0400a0 	add	x0, x5, x4
    382c:	eb00005f 	cmp	x2, x0
    3830:	54000068 	b.hi	383c <memcmp+0x20>  // b.pmore
    3834:	52800000 	mov	w0, #0x0                   	// #0
		res = *su1++ - *su2++;
		if (res)
			break;
	}
	return res;
    3838:	14000006 	b	3850 <memcmp+0x34>
		res = *su1++ - *su2++;
    383c:	386468a3 	ldrb	w3, [x5, x4]
    3840:	38646820 	ldrb	w0, [x1, x4]
		if (res)
    3844:	91000484 	add	x4, x4, #0x1
    3848:	6b000060 	subs	w0, w3, w0
    384c:	54fffee0 	b.eq	3828 <memcmp+0xc>  // b.none
}
    3850:	d65f03c0 	ret

0000000000003854 <memchr>:

void *memchr(const void *s, int c, size_t count)
{
	const unsigned char *p = s;

	while (count--)
    3854:	8b020002 	add	x2, x0, x2
		if ((unsigned char)c == *p++)
    3858:	12001c21 	and	w1, w1, #0xff
	while (count--)
    385c:	eb02001f 	cmp	x0, x2
    3860:	54000061 	b.ne	386c <memchr+0x18>  // b.any
			return (void *)(p - 1);
	return NULL;
    3864:	d2800000 	mov	x0, #0x0                   	// #0
}
    3868:	d65f03c0 	ret
		if ((unsigned char)c == *p++)
    386c:	aa0003e3 	mov	x3, x0
    3870:	38401464 	ldrb	w4, [x3], #1
    3874:	6b01009f 	cmp	w4, w1
    3878:	54ffff80 	b.eq	3868 <memchr+0x14>  // b.none
    387c:	aa0303e0 	mov	x0, x3
    3880:	17fffff7 	b	385c <memchr+0x8>

0000000000003884 <__memset>:
}

void *memset(void *s, int c, size_t count)
{
	char *xs = s;
	while (count--)
    3884:	d2800003 	mov	x3, #0x0                   	// #0
    3888:	eb03005f 	cmp	x2, x3
    388c:	54000041 	b.ne	3894 <__memset+0x10>  // b.any
		*xs++ = c;
	return s;
}
    3890:	d65f03c0 	ret
		*xs++ = c;
    3894:	38236801 	strb	w1, [x0, x3]
    3898:	91000463 	add	x3, x3, #0x1
    389c:	17fffffb 	b	3888 <__memset+0x4>

00000000000038a0 <strnlen>:
 */
size_t strnlen(const char * s, size_t count)
{
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
    38a0:	8b010001 	add	x1, x0, x1
    38a4:	aa0003e2 	mov	x2, x0
    38a8:	eb01005f 	cmp	x2, x1
    38ac:	54000060 	b.eq	38b8 <strnlen+0x18>  // b.none
    38b0:	39400043 	ldrb	w3, [x2]
    38b4:	35000063 	cbnz	w3, 38c0 <strnlen+0x20>
		/* nothing */;
	return sc - s;
    38b8:	cb000040 	sub	x0, x2, x0
}
    38bc:	d65f03c0 	ret
	for (sc = s; count-- && *sc != '\0'; ++sc)
    38c0:	91000442 	add	x2, x2, #0x1
    38c4:	17fffff9 	b	38a8 <strnlen+0x8>

00000000000038c8 <_strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * _strrchr(const char * s, int c)
{
    38c8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    38cc:	aa0003e4 	mov	x4, x0
    38d0:	2a0103e3 	mov	w3, w1
    38d4:	910003fd 	mov	x29, sp
	const char *p = s + strlen(s);

	do {
		if (*p == (char)c)
    38d8:	12001c63 	and	w3, w3, #0xff
	const char *p = s + strlen(s);
    38dc:	97ffffc9 	bl	3800 <strlen>
    38e0:	8b000080 	add	x0, x4, x0
		if (*p == (char)c)
    38e4:	39400001 	ldrb	w1, [x0]
    38e8:	6b03003f 	cmp	w1, w3
    38ec:	540000a0 	b.eq	3900 <_strrchr+0x38>  // b.none
			return (char *)p;
	} while (--p >= s);
    38f0:	d1000400 	sub	x0, x0, #0x1
    38f4:	eb00009f 	cmp	x4, x0
    38f8:	54ffff69 	b.ls	38e4 <_strrchr+0x1c>  // b.plast
	return NULL;
    38fc:	d2800000 	mov	x0, #0x0                   	// #0
}
    3900:	a8c17bfd 	ldp	x29, x30, [sp], #16
    3904:	d65f03c0 	ret
